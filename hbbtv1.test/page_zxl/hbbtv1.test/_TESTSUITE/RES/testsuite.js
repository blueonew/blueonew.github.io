/*
 * Copyright (C) 2011, 2012, 2013, 2015
 * Eurofins Digital Product Testing UK Ltd
 *
 * Ligada iSuite's implementation of the HbbTv Test Specification JavaScript
 * API.
 *
 *****************************************************************************
 * Information for Ligada iSuite customers:
 *
 * This file is part of the Ligada iSuite Test Harness.  It is not to be
 * distributed except as part of a licensed Ligada iSuite Test Harness.
 *
 * For documentation of the API of this file, see the HbbTV Test Specification.
 * If you want documentation of any Ligada-specific extensions, please ask
 * Eurofins Digital Testing.
 *
 * The implementation of this file is an implementation detail and is likely to
 * change in future Ligada releases.  Please use the documented API.
 *
 * Note that some APIs are optional.  In that case the API is provided in this
 * file but when you try to use it, if you do not have the right license then
 * it will error.
 *
 * If you are shipping a Test Suite, you should NOT ship RES/testsuite.js.
 * When that file is requested over HTTP, or when the test directs Ligada to
 * insert that file into a DSMCC carousel, then the Ligada iSuite test harness
 * will automagically provide the right version of this file.
 *
 ******************************************************************************
 * Below this point, the comments in this file are aimed at Eurofins developers
 * working on Ligada iSuite, and they may not be relevant to customers.
 ******************************************************************************
 *
 * Information for Eurofins developers:
 *
 * This file defines exactly one global symbol, HbbTVTestAPI.
 * It must not define any others as that may cause clashes with identifiers
 * used in test case code.
 *
 * If you make changes to this file, run:
 * sudo ~/guestos/installed/harness-based-test-runner/install-harness-based-test-runner.sh
 *
 * Documentation for the public API provided by this file is included in the
 * normal Ligada developer documentation set.
 *
 * The internal documentation for this file can be generated by running:
 *   sudo npm -g install jsdoc
 *   jsdoc -a all testsuite.js
 *   firefox out/index.html &
 */

/*jslint browser: true */
/*global global, module, require, window */

/**
 * The internal namespace for this file<p>
 *
 * We us an Immediately-invoked Function Expression here so we can define
 * several helper functions and classes that are only visible inside this
 * file.<p>
 *
 * The only symbol that gets exposed to the outside world is
 * <code>HbbTVTestAPI</code>, which is defined near the end of this file.
 *
 * @name Internal
 * @namespace Internal
 */
var HbbTVTestAPI = (function () {
    'use strict';


    // ------------- Private functions: Backports of modern JavaScript --------

    /** A version of the standard "undefined" symbol that can't be changed
     * by code outside of this file, even on older JavaScript runtimes.
     *
     * @alias Internal.undefined
     */
    var undefined;

    /** RE used by parseJson.  Adapted from the public domain json2.js parser.
     *
     * @alias Internal.cx_for_json
     */
    var cx_for_json = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;

    /**
     * JSON parser.
     *
     * Pass a string, it will either return a value or throw a SyntaxError.
     * Adapted from the public domain json2.js parser, available at:
     * https://github.com/douglascrockford/JSON-js/blob/master/json2.js
     *
     * (Note: JSON.parse is in HbbTV 1.3.1 but is not required by earlier
     * versions of HbbTV, so we have to use this instead).
     *
     * @param {string} text Text to parse
     * @returns Parsed JSON data
     * @alias Internal.parseJson
     */
    function parseJson(text) {
        text = String(text);
        cx_for_json.lastIndex = 0;
        if (cx_for_json.test(text)) {
            text = text.replace(cx_for_json, function (a) {
                return '\\u' +
                    ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
            });
        }

        if (/^[\],:{}\s]*$/
                .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
                    .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
                    .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

            return eval('(' + text + ')');
        }
        throw new SyntaxError('parseJson');
    }

    /**
     * Parse some JSON, when you expect a dictionary (and not just a simple
     * number or string).
     *
     * @param {string} text Text to parse
     * @returns Parsed JSON data
     * @alias Internal.parseJsonDict
     */
    function parseJsonDict(text) {
        var j = parseJson(text);
        if (typeof j !== 'object' || j === null || j === undefined) {
            throw new SyntaxError('Not a dictionary');
        }
        return j;
    }

    /**
     * Check to see if an item is present within a list.
     *
     * Cannot use indexOf because we are restricted to ECMAScript v3
     * if running on a HbbTV 1.2.1 or earlier device.
     *
     * @param list List to look in
     * @param item Item to look for
     * @returns {Boolean} True if found, false if not.
     * @alias Internal.listContains
     */
    function listContains(list, item) {
        var i;
        for (i = 0; i < list.length; i += 1) {
            if (list[i] === item) {
                return true;
            }
        }
        return false;
    }


    // ------------- Private functions: Debug Utilities -----------------------

    /**
     * Print a debugging message.
     *
     * @function
     * @param {string} msg The message to print
     * @alias Internal.debugPrint
     */
    var debugPrint = (function () {
        // The most recent debugging messages.
        //
        // The real definition of debugPrint() is wrapped in an
        // Immediately-invoked Function Expression so we can save
        // visible_debug_messages across calls to debugPrint(), without
        // polluting the namespace.
        //
        // Normally, all state lives in the HbbTVTestAPI object or sub-objects,
        // which makes unit testing much easier.  debugPrint() is the ONLY
        // exception to that rule.  This exception makes it easy to use
        // debugPrint() from all our code, and doesn't interfere with unit
        // testing.
        var visible_debug_messages = [];

        // Print a debug message.
        // NOTE: For harness-based tests running within Ligada, currently this
        // will log to /var/log/supervisor/ligada-harness-based-test-runner.log
        return function (msg) {
            // Can't do XMLHttpRequest back to TestServer here, because the
            // network might be down, and also because this is called in the
            // XMLHttpRequest error path.

            // Print a debug message using OIPF global window.debug(), S7.15.5,
            // p208 OIPF
            try {
                window.debug(msg);
            } catch (ignore) {
                // If window.debug doesn't exist, or fails, ignore this error
                // and continue anyway.
            }

            // Add the debug message to the test's HTML.
            //
            // Optionally, the test's HTML can include a
            //     <div id="debugging"></div>
            // If present, we add the most recent 10 debug() messages to it,
            // with each message in a separate <div>.
            // If not present, we just return.
            try {
                // The maximum number of debugging messages to keep.
                // A constant.
                var debug_max_entries = 10;

                var debugitem = document.getElementById('debugging');
                if (debugitem === null) {
                    return;
                }
                if (debugitem.length === 0) {
                    return;
                }
                //debugitem = debugitem[0];

                if (visible_debug_messages.length > debug_max_entries) {
                    visible_debug_messages.shift();
                }
                visible_debug_messages.push('<div>' + msg + '</div>');

                debugitem.innerHTML = '';
                var i;
                for (i = visible_debug_messages.length - 1; i >= 0; i = i - 1) {
                    debugitem.innerHTML += visible_debug_messages[i];
                }
            } catch (ignore) {
                // If something goes wrong adding the debug message, we don't
                // care.  We just continue anyway.
            }
        };
    }());

    /**
     * Class used for assertion exceptions.  Only used by assert().
     *
     * @class
     * @param {string} msg The message explaining the failure.
     * @alias Internal.AssertFailed
     */
    function AssertFailed(msg) {
        if (!(this instanceof AssertFailed)) {
            throw new Error("Must use 'new' when constructing a AssertFailed");
        }
        this.msg = msg;
    }

    /**
     * Used to check "should always be true" properties in testsuite.js.
     *
     * Note: Do not use this for things that the _test_ can get wrong, or
     * things the _RUT_ can get wrong.  Only use this to detect bugs in
     * testsuite.js itself.
     *
     * @param {Boolean} cond The condition to be checked for truthyness
     * @param {string} msg The message to show if the assertion fails
     * @alias Internal.assert
     */
    function assert(cond, msg) {
        if (!cond) {
            debugPrint('Assertion fail: ' + msg);
            throw new AssertFailed('Assertion fail: ' + msg);
        }
    }


    // ------------- Private functions: Callback helper -----------------------

    /**
     * @callback HbbtvCallback
     * @param {} callbackObject The callback object set by the test case
     */

    /**
     * Calls a callback, handling exceptions and missing callbacks.<p>
     *
     * Pass in a callback or falsy, and the parameters to pass to that
     * callback.  If the first parameter is falsy, does nothing.
     * Else, calls the callback with the provided arguments and logs but
     * otherwise ignores any exceptions.  The "this" context in the
     * callback will be either undefined or the global object: it is
     * undefined in an EcmaScript 5 compliant JavaScript engine,
     * e.g. HbbTV 2.0, or the global object in an EcmaScript 3 JavaScript
     * engine, e.g. HbbTV 1.0/1.5.
     *
     * @param {?Function} callback The callback to call, or a falsy value
     *                             for no callback
     * @param {} ... Extra parameters to pass to the callback.
     *
     * @alias Internal.checkCallback
     */
    function checkCallback(callback) {
        var args = Array.prototype.slice.call(arguments, 1);
        if (callback !== null && callback !== undefined) {
            try {
                if (callback) {
                    callback.apply(this, args);
                }
            } catch (ex) {
                // This is a bug in the callback that the test provided.
                // Report it to the user.
                debugPrint('Testcase raised an unhandled Exception in the callback');
                try {
                    debugPrint('Testcase Exception in callback is: ' + ex);
                } catch (ignore) {
                    // Not sure if formatting the message can throw...
                    // if it does, ignore it.  (And we already reported a
                    // generic error message earlier).
                }
            }
        }
    }

    /**
     * Wraps a HbbTV-style callback.
     *
     * Pass in a callback in the HBBTV test API style.
     * Returns a simple no-argument function that calls the callback.
     *
     * Handles the case where the callback is null - returns a function that
     * does nothing.  Handles exceptions thrown by the callback, so the
     * returned function never throws.
     *
     * @param {?HbbtvCallback} callback The callback to call, or a falsy value
     *                                  for no callback
     * @param {} callbackObject The parameter to pass to the callback.
     * @returns A function that will call the callback with the correct
     *          parameter and catch and handle any exceptions.  Or, if callback
     *          was falsy, a function that does nothing.
     * @alias Internal.wrapCallback
     */
    function wrapCallback(callback, callbackObject) {
        return function () {
            checkCallback(callback, callbackObject);
        };
    }


    // ------------- Launch modes for this file ----------------------------

    /**
     * Class to identify the way that this testsuite.js file was invoked.<p>
     *
     * There are 4 ways to run this code:<ul>
     * <li> In a HbbTV application on the RUT, launched from an AIT
     * <li> In an application (HbbTV or OIPF or HTML) on the RUT, launched from
     *      the http://a.aa/ launcher.
     * <li> In a harness-based test, on the server, in node.js.
     * <li> Running the unit tests for this file.</ul>
     *
     * @class
     * @param {HbbTVTestApi} test_api The HbbTVTestApi instance.  Used to check
     *         for certain special class-level properties that are set by
     *         Ligada's launchers when running this code inside the harness
     *         and when running the unit tests.
     * @alias Internal.LaunchMode
     */
    function LaunchMode(test_api) {
        if (!this instanceof LaunchMode) {
            throw new Error("Must use 'new' when constructing a LaunchMode");
        }

        /**
         * True if this is a harness-based test, else false.<p>
         *
         * Initialised by checking for a magic property set on the HbbTVTestAPI
         * class prototype.  That property will be set to true by our node.js
         * initialisation code, and will not exist otherwise.<p>
         *
         * Amongst other things, this flag is used to disable the watchdog,
         * since we can kill harness based tests with "kill -9".
         *
         * @type {boolean}
         */
        this.is_harness_application = test_api.__isHarnessApplication === true;

        /**
         * True if we are running the testsuite.js unit tests, else false.<p>
         *
         * Initialised by checking for a magic property set on the HbbTVTestAPI
         * class prototype.  That property will be set to true by our unit test
         * initialisation code, and will not exist otherwise.<p>
         *
         * To enable this file (testsuite.js) to be unit tested, we do some
         * things slightly differently in unit test mode.
         *
         * @type {boolean}
         */
        this.is_unit_test = test_api.__isUnitTest === true;

        /**
         * Whether this app was started from the http://a.aa/ launcher.<p>
         *
         * Initially undefined; this will be set to true or false by the
         * startup XHR.
         *
         * @type {boolean|undefined}
         */
        this.is_run_from_launcher = undefined;
    }


    // ------------- URL definitions -----------------------------

    /**
     * URL fragments used by this file.<p>
     *
     * Note these URLS match the functions in guestos/installed/site_src/
     * ligada/plugins/dial_router.py except that the call magically converts
     * the '-' into '_'
     * Note also that this appears to fail if there is a digit in the name!
     *
     * @alias Internal.URLS
     */
    var URLS = {
        // Ligada infrastructure
        makeTestFail: 'make-test-fail/?',
        isTestActiveOrComplete: 'is-test-id-active-or-complete/?',

        // HbbTV test spec: APIs Interacting with the Device under Test
        getPlayoutInformation: 'get-playout-info/',
        endTest: 'end-test/',
        reportStepResult: 'report-step-result/?',
        sendMessage: 'send-message/?',
        manualAction: 'manual-action/?',
        sendPointerCode: 'send-pointer-code/?',
        moveWheel: 'move-wheel/?',

        // HbbTV test spec: chapter 7.3
        initiatePowerCycle: 'initiate-power-cycle/?',
        sendKeyCode: 'send-key-code/?',
        analyseScreenPixel: 'analyse-screen-pixel/?',
        analyseScreenExtended: 'analyse-screen-extended/?',
        analyseAudioFrequency: 'analyse-audio-frequency/?',
        analyseAudioExtended: 'analyse-audio-extended/?',
        analyseVideoExtended: 'analyse-video-extended/?',
        analyseManual: 'analyse-manual/?',
        selectServiceByRemoteControl: 'select-service-by-remote-control/?',

        // HbbTV test spec: chapter 7.4
        changePlayoutSet: 'change-playout-set/?',
        setNetworkBandwidth: 'set-network-bandwidth/?',

        // HbbTV test spec: Media Sync testing APIs
        analyzeAvSync: "analyze-av-sync/?",
        analyzeStartVideoGraphicsSync: "analyze-start-video-graphics-sync/?",
        analyzeFinishVideoGraphicsSync: "analyze-finish-video-graphics-sync/?",
        analyzeAvNetSync: "analyze-av-net-sync/?",
        startFakeSyncMaster: "start-fake-sync-master/?",
        getPlayoutStartTime: "get-playout-start-time/?",
        analyzeCssWcPerformance: "analyze-css-wc-performance/?",

        // HbbTV test spec: CI+ testing APIs
        cicamSetScramblingEnabled: 'cicam-set-scrambling-enabled/?',
        cicamSendSystemInfo: 'cicam-send-system-info/?',
        cicamSendReply: 'cicam-send-reply/?',
        cicamSendParentalControlInfo: 'cicam-send-parental-control-info/?',
        cicamSendRightsInfo: 'cicam-send-rights-info/?',
        cicamClearAuthentication: 'cicam-clear-authentication/?',
        cicamSendUri: 'cicam-send-uri/?',
        cicamWaitForMessageStart: 'cicam-wait-for-message-start/?',
        cicamWaitForMessageEnd: 'cicam-wait-for-message-end/?',
        cicamRunScriptGetOutput: 'cicam-run-script-get-output/?',

        // HbbTV test spec: DIAL testing APIs
        dialMSearch: 'dial-m-search/?',
        dialDeviceDesc: 'dial-device-desc/?',
        dialHbbtvAppDesc: 'dial-hbbtv-app-desc/?',
        dialStartHbbtvApp: 'dial-start-hbbtv-app/?',
        dialSendOptionsRequest: 'dial-send-options-request/?',
        dialResolveIpV4Address: 'dial-resolve-ip-address/?',

        // OIPF test spec
        setDefaultPage: 'set-default-page/?',

        // Ligada extension: Network Shaping
        changeNetworkProfile: 'change-network-profile/?'
    };


    // ------------- Private functions: Watchdog -----------------------------

    /**
     * Terminate the currently running application.<p>
     *
     * The behaviour depends on how the currently running application was
     * originally launched:<p><ul>
     *
     * <li> For harness based tests, we do nothing and wait for the harness to
     *      do "kill -9"
     * <li> For tests run from the http://a.aa/ launcher, we navigate to
     *      that launcher
     * <li> For tests run as HbbTV apps, we use the HbbTV application manager
     *      APIs to destroy the application.</ul>
     *
     * @param {LaunchMode} launch_mode The current launch mode
     * @alias Internal.destroyApplication
     */
    function destroyApplication(launch_mode) {
        var appManObj, appObj, i, tags;
        if (launch_mode.is_harness_application) {
            // Harness based test
            // No need to do anything here; harness is about to do "kill -9"
            // on the entire JavaScript runtime.
        } else if (launch_mode.is_run_from_launcher) {
            // App was launched from the "a.aa" launcher.  So navigate
            // to the launcher.
            window.location = 'http://a.aa/';
        } else {
            // HbbTV style app
            debugPrint("Detected Ligada iSuite has terminated test: " +
                       "attempting to destroy application");
            // See if there's an existing opifApplicationManager:
            appManObj = undefined;
            tags = document.getElementsByTagName('object');
            for (i = 0; i < tags.length; i += 1) {
                if (tags[i].type === 'application/oipfApplicationManager') {
                    appManObj = tags[i];
                    debugPrint("Found existing application manager");
                }
            }
            // If not, create one
            if (appManObj === undefined) {
                appManObj = document.createElement('object');
                appManObj.setAttribute('type',
                                       'application/oipfApplicationManager');
                document.body.appendChild(appManObj);
            }

            // Get application and destroy it
            // If running on a non-oipf device this method may not exist, so
            // test for it
            if (typeof appManObj.getOwnerApplication === "function") {
                appObj = appManObj.getOwnerApplication(document);
                appObj.destroyApplication();
            }
        }
    }

    /**
     * The watchdog.<p>
     *
     * This function starts a watchdog that regularly checks whether the test
     * should still be running or not.  If not, it terminates the test
     * application.  There are 2 cases where this is useful:<ul>
     *
     * <li> With a broadcast-independent application, the DUT is not checking
     *      the AIT any more.  So this is the only way to automatically
     *      terminate a HbbTV broadcast-independent application at the end of a
     *      test.
     * <li> With non-HbbTV applications, such as OIPF or vanilla HTML, there is
     *      no out-of-band signalling to terminate the application at the end
     *      of the test.  So this is the only way to automatically terminate
     *      them.</ul><p>
     *
     * While intended for those 2 cases, it actually runs for all tests except
     * harness based ones.  (For harness based tests, we terminate the test
     * with "kill -9", which is completely reliable).
     *
     * @param {LaunchMode} launch_mode The current launch mode
     * @param {string} ajax_root_url The base URL for all AJAX calls to the
     *                               server.
     * @alias Internal.startWatchdog
     */
    function startWatchdog(launch_mode, ajax_root_url) {
        // Watchdog poll interval (milliseconds).
        var gWatchdogPollInterval = 10000;

        var watchdogCheck;

        function watchdogXhrStateChange(req) {
            if (req.readyState !== 4) {
                // XHR not yet finished
                return;
            }

            // Can't reliably determine the difference between "error in Ligada
            // VM" and "network is down", due to some buggy RUTs inventing
            // req.status values for "network is down" instead of using the
            // stanadard value of 0.  So assume anything other than 200 means
            // "network is down".
            if (req.status === 200) {
                var response;
                try {
                    response = parseJsonDict(req.responseText);
                } catch (ex) {
                    debugPrint('Ligada iSuite watchdog request failed: ' +
                               'server returned incorrectly formatted ' +
                               'response');
                    debugPrint("Parse error was: " + ex);
                    // Do not restart watchdog timer.
                    // This is a "should never happen" scenario.  So if this
                    // has gone wrong, give up.
                    return;
                }

                if (response.type === 'FALSE') {
                    debugPrint("Ligada iSuite reports that test should no " +
                               "longer be running");
                    // Need to delay here, in case the broadcast AIT is still
                    // signalling the application.  Without a delay, we'd
                    // kill the app and then it would restart from the AIT.
                    //
                    // So we have to add a delay that is larger than the sum
                    // of:
                    //   * DVB modulator buffering, plus
                    //   * the AIT repeat period, plus
                    //   * the time the terminal takes to notice the AIT update
                    //
                    // TODO: window.setTimeout(function () {
                    //           destroyApplication(launch_mode);
                    //       }, 10000);
                    destroyApplication(launch_mode);
                    return;
                }
                if (response.type === 'ERROR') {
                    if (response.msg) {
                        debugPrint('Ligada iSuite watchdog request failed: ' +
                                   'Server reports error: ' + response.msg);
                    } else {
                        debugPrint('Ligada iSuite watchdog request failed: ' +
                                   'Server reports unknown error');
                    }
                } else if (response.type !== 'TRUEY') {
                    debugPrint('Ligada iSuite watchdog request failed: ' +
                               'server returned incorrect response');
                }
            }
            // Always reset timer, even if XHR failed, unless we've actually
            // killed the app.
            window.setTimeout(watchdogCheck, gWatchdogPollInterval);
        }

        // Called at startup after the startup XHR completes, and every
        // gWatchdogPollInterval milliseconds thereafter. Asks the server if
        // the test application should be running, given the current test_id.
        // If the server says no then the application is terminated.
        watchdogCheck = function () {
            if (launch_mode.is_harness_application) {
                // Harness apps are killed with "kill -9", we don't need a
                // watchdog.
                return;
            }
            var req = new XMLHttpRequest();
            req.open('POST', ajax_root_url + URLS.isTestActiveOrComplete, true);
            req.setRequestHeader('Content-Type',
                                 'application/x-www-form-urlencoded');
            req.onreadystatechange = function () {
                watchdogXhrStateChange(req);
            };
            req.send(null);
        };

        watchdogCheck();
    }


    // ------------- Private functions: Parameter validation ------------------

    /**
     * Class to perform parameter validation of public API methods.<p>
     *
     * To use this:<ol>
     *
     * <li> create a ValidateObject instance
     * <li> use convertStringToPrimitive if needed
     * <li> then pass the (converted if applicable) parameters to the other
     *      ValidateObject methods to check them.</ol><p>
     *
     * On error, the check methods will throw a nice user-friendly error
     * message that you can catch and pass to makeTestFail.  See the existing
     * public APIs for examples.
     *
     * @class
     * @param {string} call The name of the function that the test case called,
     *                      for use in error messages.
     * @alias Internal.ValidateObject
     */
    function ValidateObject(call) {
        var vo = this;

        if (!(this instanceof ValidateObject)) {
            throw new Error("Must use 'new' when constructing a ValidateObject");
        }

        /**
         * Throw an exception with an error message.<p>
         *
         * Creates an error message containing the function call name and the
         * details from the passed message.
         *
         * @param {string} message The message to include in the exception.
         * @throws {string} Always throws a user-friendly error message.
         */
        function throwError(message) {
            var fail_prefix = "Test implementation error - bad call to " +
                               call + "(): ";
            throw (fail_prefix + message);
        }

        /**
         * Converts String objects to normal (primitive) strings.
         * If the parameter is not a String, returns it unchanged.
         * (It is assumed that the caller will do proper type checking
         * *after* the call to this function).
         *
         * @param {} s The object to possibly convert
         * @returns Either converted object or passed object.
         */
        this.convertStringToPrimitive = function (s) {
            if (s !== null && s !== undefined) {
                if (typeof s === 'object' && s.constructor === String) {
                    s = s.valueOf();
                }
            }
            return s;
        };

        /**
         * Check an object is a string and representable in XML.<p>
         *
         * JavaScript strings can contain unmatched surrogates, which
         * are not representable in any proper Unicode encoding.  (JavaScript
         * uses a special "UTF-16 but unmatched surrogates are allowed"
         * encoding).  So we reject strings containing them.<p>
         *
         * The "representable in XML" rule is so we can include messages in
         * the XML reports.  E.g. U+0000 and many control characters are
         * forbidden in XML.<p>
         *
         * These limitations are allowed by the HbbTV Test Spec.
         *
         * @param {} object The object to check.
         * @param {string} parameterName The name of the API parameter that
         *         is being validated, for use in error messages.
         * @throws {string} If validation fails, a user-friendly error message.
         */
        this.objectIsString = function (object, parameterName) {
            if (typeof object !== "string") {
                throwError(parameterName + " is not a string, " +
                              "it is a " + (typeof object) +
                              " with value " + object);
            }
            // Check that the string is valid according to the XML 1.0
            // specification. Otherwise, fail the test.
            var goodUtf16 = new RegExp(
                    '^([\u0009-\u000A\u0020-\uD7FF\uE000-\uFFFD]' +
                        '|([\uD800-\uDBFF][\uDC00-\uDFFF]))*$'
                );

            if (!goodUtf16.test(object)) {
                throwError(parameterName + ' contains invalid UTF-16 or' +
                           ' UTF-16 that does not conform to the XML 1.0' +
                           ' specification');
            }
        };

        /**
         * Check an object is either a string and representable in XML, or
         * null.<p>
         *
         * Like [objectIsString()]{@linkcode
         * Internal.ValidateObject#objectIsString} but allows null.
         *
         * @param {} object The object to check.
         * @param {string} parameterName The name of the API parameter that
         *         is being validated, for use in error messages.
         * @throws {string} If validation fails, a user-friendly error message.
         */
        this.objectIsNullOrString = function (object, parameterName) {
            if (object !== null) {
                vo.objectIsString(object, parameterName);
            }
        };

        /**
         * Check an object is a string, matches a specified regular experssion,
         * and is representable in XML.<p>
         *
         * Like [objectIsString()]{@linkcode
         * Internal.ValidateObject#objectIsString} but also checks against a
         * regular expression.
         *
         * @param {} object The object to check.
         * @param {string} regEx The regular expression to use to validate
         *                       the string.
         * @param {string} customMessage The error message to use if the
         *         regular expression check fails.  Will be automatically
         *         prefixed with a standard message that includes the function
         *         name but not the parameter name.
         * @param {string} parameterName The name of the API parameter that
         *         is being validated, for use in error messages.
         * @throws {string} If validation fails, a user-friendly error message.
         */
        this.objectIsFormattedString = function (object, regEx, customMessage,
                                                 parameterName) {
            vo.objectIsString(object, parameterName);
            if (!(new RegExp(regEx).test(object))) {
                throwError(customMessage);
            }
        };

        /**
         * @param {} object The object to check.
         * @param min
         * @param max
         * @param {string} parameterName The name of the API parameter that
         *         is being validated, for use in error messages.
         */
        this.objectIsStringLengthInRange = function (object, min, max,
                                                     parameterName) {
            vo.objectIsString(object, parameterName);
            if (object.length < min) {
                throwError(parameterName + " has fewer than " + min +
                           " characters");
            }
            if (object.length > max) {
                throwError(parameterName + " has greater than " + max +
                           " characters");
            }
        };

        /**
         * @param {} object The object to check.
         * @param array
         * @param {string} parameterName The name of the API parameter that
         *         is being validated, for use in error messages.
         */
        this.objectIsStringFromArray = function (object, array, parameterName) {
            vo.objectIsString(object, parameterName);
            if (!(new RegExp('^(' + array.join('|') + ')$').test(object))) {
                throwError(parameterName + " is not in the list of " +
                              "accepted values");
            }
        };

        /**
         * @param {} object The object to check.
         * @param {string} parameterName The name of the API parameter that
         *         is being validated, for use in error messages.
         */
        this.objectIsHexBinaryString = function (object, parameterName) {
            var hexBinaryRegex = /^([A-Fa-f0-9]{2})*$/;
            var errMessage = parameterName + " is not a valid hexBinary " +
                "string: either contains characters other than a-f, A-F, " +
                "0-9, or contains an odd number of characters";

            vo.objectIsFormattedString(object, hexBinaryRegex, errMessage,
                                       parameterName);
        };

        /**
         * @param {} object The object to check.
         * @param {string} parameterName The name of the API parameter that
         *         is being validated, for use in error messages.
         */
        this.objectIsNumber = function (object, parameterName) {
            if (typeof object !== "number") {
                throwError(parameterName + " is not a number, " +
                              "it is a " + (typeof object) +
                              " with value " + object);
            }
        };

        /**
         * @param {} object The object to check.
         * @param {string} parameterName The name of the API parameter that
         *         is being validated, for use in error messages.
         */
        this.objectIsInteger = function (object, parameterName) {
            vo.objectIsNumber(object, parameterName);
            if (!isFinite(object)) {
                // NaN, +Infinity or -Infinity
                throwError(parameterName + " is not an integer, " +
                              "it is " + object);
            }
            if (parseInt(object, 10) !== object) {
                throwError(parameterName + " is not an integer, " +
                              "it has a fractional part (" + object + ")");
            }
        };

        /**
         * @param {} object The object to check.
         * @param {string} parameterName The name of the API parameter that
         *         is being validated, for use in error messages.
         */
        this.objectIsNonNegativeInteger = function (object, parameterName) {
            vo.objectIsInteger(object, parameterName);
            if (object < 0) {
                throwError(parameterName + " is not a positive integer, " +
                              "it is a " + (typeof object) +
                              " with value " + object);
            }
        };

        /**
         * @param {} object The object to check.
         * @param {string} parameterName The name of the API parameter that
         *         is being validated, for use in error messages.
         */
        this.objectIsPositiveInteger = function (object, parameterName) {
            vo.objectIsInteger(object, parameterName);
            if (object <= 0) {
                throwError(parameterName + " is not a positive integer, " +
                              "it is a " + (typeof object) +
                              " with value " + object);
            }
        };

        /**
         * @param {} object The object to check.
         * @param {string} parameterName The name of the API parameter that
         *         is being validated, for use in error messages.
         */
        this.objectIsBoolean = function (object, parameterName) {
            if (typeof object !== "boolean") {
                throwError(parameterName + " is not a boolean value, " +
                              "it is a " + (typeof object) +
                              " with value " + object);
            }
        };

        /**
         * @param {} object The object to check.
         * @param {string} parameterName The name of the API parameter that
         *         is being validated, for use in error messages.
         */
        this.objectIsFunction = function (object, parameterName) {
            if (typeof object !== "function") {
                throwError(parameterName + " is not a function " +
                              "it is a " + (typeof object) +
                              " with value " + object);
            }
        };

        /**
         * @param {} object The object to check.
         * @param {string} parameterName The name of the API parameter that
         *         is being validated, for use in error messages.
         */
        this.objectIsFunctionOrFalsy = function (object, parameterName) {
            if (object && typeof object !== "function") {
                throwError(parameterName + " is not a function/null, " +
                              "it is a " + (typeof object) +
                              " with value " + object);
            }
        };

        /**
         * @param {} object The object to check.
         * @param min
         * @param max
         * @param {string} parameterName The name of the API parameter that
         *         is being validated, for use in error messages.
         */
        this.objectIsIntegerInRange = function (object, min, max,
                                                parameterName) {
            vo.objectIsInteger(object, parameterName);
            if (object < min || object > max) {
                throwError(parameterName + " is " + object +
                    ". This must be an integer within the range of " +
                    min + " to " + max);
            }
        };

        /**
         * @param {} object The object to check.
         * @param choices
         * @param {string} parameterName The name of the API parameter that
         *         is being validated, for use in error messages.
         */
        this.objectIsIntegerInList = function (object, choices, parameterName) {
            vo.objectIsInteger(object, parameterName);
            if (!listContains(choices, object)) {
                throwError(parameterName + " is " + object +
                    ". This must be an integer in the list " + choices);
            }
        };

        /**
         * @param {} object The object to check.
         * @param {string} parameterName The name of the API parameter that
         *         is being validated, for use in error messages.
         */
        this.objectIsDictionary = function (object, parameterName) {
            if (object === null || object === undefined) {
                throwError(parameterName + " must be non null");
            }
            if (typeof object !== "object") {
                throwError(parameterName + " must be a dictionary");
            }
        };

        /**
         * @param {} object The object to check.
         * @param {string} parameterName The name of the API parameter that
         *         is being validated, for use in error messages.
         */
        this.objectIsArrayOrNull = function (object, parameterName) {
            if (object !== null &&
                    (typeof object !== 'object' ||
                    Object.prototype.toString.call(object) !==
                    "[object Array]")) {
                throwError(parameterName + " must be an Array (or null)");
            }

        };

        /**
         * @param {} object The object to check.
         * @param {string} parameterName The name of the API parameter that
         *         is being validated, for use in error messages.
         * @param min_size
         * @param max_size
         * @param min_value
         * @param max_value
         */
        this.objectIsIntArray = function (object, parameterName, min_size,
                                          max_size, min_value, max_value) {
            var i;
            if (object === null) {
                throwError(parameterName + " must be an integer Array");
            }
            vo.objectIsArrayOrNull(object, parameterName);
            if (object.length < min_size) {
                throwError(parameterName + " must be an integer Array with " +
                           "at least " + min_size + " elements");
            }
            if (object.length > max_size) {
                throwError(parameterName + " must be an integer Array with " +
                           "at most " + max_size + " elements");
            }
            for (i = 0; i < object.length; i += 1) {
                vo.objectIsIntegerInRange(object[i], min_value, max_value,
                    "Item " + i + " in " + parameterName);
            }
        };

        /**
         * @param {} object The object to check.
         * @param min
         * @param max
         * @param {string} parameterName The name of the API parameter that
         *         is being validated, for use in error messages.
         */
        this.objectIsNullOrIntArray = function (object, min, max,
                                                parameterName) {
            var i;
            vo.objectIsArrayOrNull(object, parameterName);
            if (object !== null) {
                for (i = 0; i < object.length; i += 1) {
                    vo.objectIsIntegerInRange(object[i], min, max,
                        "Item " + i + " in " + parameterName);
                }
            }
        };

    }


    // ------------- Private functions: analyzeScreenPixel GUI ----------------

    /**
     * The GUI for analyzeScreenPixel<p>
     *
     * analyse_pixel_gui is a namespace - i.e. it stores no state, it's just to
     * group the functions together and allow for private functions that are
     * only callable within this block.<p>
     *
     * Member functions: show(), hide(), and getScreenSize().
     *
     * @namespace
     * @alias Internal.analyse_pixel_gui
     */
    var analyse_pixel_gui = (function () {

        /**
         * Remove analyzeScreenPixel GUI from screen, if present.
         * Safe to call even if the GUI is not showing.
         *
         * @alias Internal.analyse_pixel_gui.hide
         */
        function hide() {
            // items required on tear-down:
            // 1) hook this into queueAjaxRequest() as an arbitrary extra arg
            // 2) remove (1) and (2) above
            try {
                document.body.removeChild(document.getElementById("outerDiv"));
            } catch (ignore) {}
        }

        /**
         * Creates a &lt;div&gt;
         *
         * @param parentelem
         * @param x1
         * @param y1
         * @param x2
         * @param y2
         * @param bgcol
         * @param semiTransparent
         * @private
         * @alias Internal.analyse_pixel_gui.createDiv
         */
        function createDiv(parentelem, x1, y1, x2, y2, bgcol,
                           semiTransparent) {
            if (x2 <= x1 || y2 <= y1) {
                return null;
            }

            var ret = document.createElement("div");
            ret.style.position = "absolute";
            ret.style.left = x1 + "px";
            ret.style.top = y1 + "px";
            ret.style.width = (x2 - x1) + "px";
            ret.style.height = (y2 - y1) + "px";
            ret.style.opacity = "1";
            ret.style.display = "block";
            ret.style.visibility = "visible";
            ret.style.overflow = "hidden";
            ret.style.margin = "0px";
            ret.style.padding = "0px";
            //ret.style.borderStyle = "solid";
            //ret.style.borderWidth = "1px";
            if (semiTransparent) {
                ret.style.opacity = 9.5 / 10;
                ret.style.filter = 'alpha(opacity=' + (9.5 * 10) + ')';
            }
            ret.style.outlineStyle = "none";
            ret.style.backgroundImage = "none";
            ret.style.backgroundColor = bgcol;
            ret.style.zIndex = "500"; // ensure it is on top
            parentelem.appendChild(ret);
            return ret;
        }

        /**
         * Called from show() to draw the on-screen boxes and text
         *
         * @param parentelem
         * @param posx
         * @param posy
         * @param maxx
         * @param maxy
         * @param sampleCol
         * @private
         * @alias Internal.analyse_pixel_gui.createSampleDiv
         */
        function createSampleDiv(parentelem, posx, posy, maxx, maxy,
                                 sampleCol) {
            // Reference statment box co-ordinates
            var posXForRefStatementBox, posYForRefStatementBox;
            // Reference pixel box y co-ordinates (varies depending on quadrant)
            var posYForRefBox;
            // Test pixel and reference pixel text tag x positions (same for
            // both)
            var posXForTag;
            var RefStatementBoxWidth = 170;
            var RefStatementBoxHeight = 60;
            // Box and tag locations calculated relative to test pixel location
            // using BoxWidth and BoxHeight specified above etc
            if (posx > maxx / 2) {  // if posx in right half of screen
                RefStatementBoxWidth = RefStatementBoxWidth + 20;
                posXForRefStatementBox = posx + 20 - RefStatementBoxWidth;
                posXForTag = posx - 150; // put text to left of pixel box
            } else {
                posXForRefStatementBox = posx - 20; // for reference statement box
                posXForTag = posx + 20; // put text to right of test pixel box
            }
            if (posy < maxy / 2) {  // if posy in top half of screen
                posYForRefBox = (posy + 15);
                posYForRefStatementBox = posYForRefBox - 35;
            } else {
                posYForRefBox = (posy - 25);
                posYForRefStatementBox = (posy - RefStatementBoxHeight + 20);
            }

            // test pixel text tag y position (relative to test pixel)
            var posYForTestTag = (posy - 9) + "px";
            // reference pixel text tag y position (relative to test pixel)
            var posYForReferenceTag = (posYForRefBox - 5) + "px";

            // create reference statement box border
            var ret = document.createElement("div");
            ret.style.position = "absolute";
            ret.style.left = posXForRefStatementBox + "px";
            ret.style.top = posYForRefStatementBox + "px";
            ret.style.width = RefStatementBoxWidth + "px";
            ret.style.height = RefStatementBoxHeight + "px";
            ret.style.borderStyle = "solid";
            ret.style.borderWidth = "1px";
            ret.style.borderColor = "#000000";
            ret.style.backgroundImage = "none";
            ret.style.backgroundColor = "transparent";
            ret.style.zIndex = "600"; // ensure it is on top
            parentelem.appendChild(ret);

            // create white background in reference statement box...
            var bgcol = "#ffffff";
            var white = document.createElement("div");
            // create white background to left of pixel in statement box
            createDiv(white,
                posXForRefStatementBox,
                posYForRefStatementBox,
                posx - 4,
                posYForRefStatementBox + RefStatementBoxHeight,
                bgcol, false);
            // create white background to right of pixel in statement box
            createDiv(white,
                posx + 5,
                posYForRefStatementBox,
                posXForRefStatementBox + RefStatementBoxWidth,
                posYForRefStatementBox + RefStatementBoxHeight,
                bgcol, false);
            // create white background extending above test pixel box
            createDiv(white,
                posx - 4,
                posYForRefStatementBox,
                posx + 5,
                posy - 5,
                bgcol, false);
            // create white background extending below test pixel box
            createDiv(white,
                posx - 4,
                posy + 5,
                posx + 5,
                posYForRefStatementBox + RefStatementBoxHeight,
                bgcol, false);
            parentelem.appendChild(white);

            // Create reference pixel box (pixels inside box must be an odd
            // number of pixels as we are checking the central pixel)
            var ref = document.createElement("div");
            ref.style.position = "absolute";
            ref.style.left = (posx - 5) + "px";
            ref.style.top = posYForRefBox + "px";
            ref.style.width = "9px";
            ref.style.height = "9px";
            ref.style.borderStyle = "solid";
            ref.style.borderWidth = "1px";
            ref.style.borderColor = "#000000";
            ref.style.outlineStyle = "none";
            ref.style.backgroundImage = "none";
            ref.style.zIndex = "600"; // ensure it is on top
            ref.style.backgroundColor = sampleCol;
            parentelem.appendChild(ref);

            // Create test pixel box (pixels inside box must be an odd number
            // of pixels as we are checking the central pixel)
            var test_box = document.createElement("div");
            test_box.style.position = "absolute";
            test_box.style.left = (posx - 5) + "px";
            test_box.style.top = (posy - 5) + "px";
            test_box.style.width = "9px";
            test_box.style.height = "9px";
            test_box.style.backgroundColor = "transparent";
            test_box.style.borderStyle = "solid";
            test_box.style.borderWidth = "1px";
            test_box.style.borderColor = "#000000";
            test_box.style.zIndex = "1000";
            parentelem.appendChild(test_box);

            // Create text tags next to test pixel box
            var tagDivForTestTag = document.createElement("div");
            tagDivForTestTag.setAttribute("id", "tagDivForTestTag");
            tagDivForTestTag.style.position = "absolute";
            tagDivForTestTag.style.left = posXForTag + "px";
            tagDivForTestTag.style.top = posYForTestTag;
            tagDivForTestTag.style.zIndex = "600";
            tagDivForTestTag.style.fontSize = "16px";
            parentelem.appendChild(tagDivForTestTag);

            // Create text tags next to reference pixel box
            var tagDivForReferenceTag = document.createElement("div");
            tagDivForReferenceTag.setAttribute("id", "tagDivForReferenceTag");
            tagDivForReferenceTag.style.position = "absolute";
            tagDivForReferenceTag.style.left = posXForTag + "px";
            tagDivForReferenceTag.style.top = posYForReferenceTag;
            tagDivForReferenceTag.style.zIndex = "600";
            tagDivForReferenceTag.style.fontSize = "16px";
            parentelem.appendChild(tagDivForReferenceTag);

            // Set text for pixel box tags
            document.getElementById('tagDivForTestTag').innerHTML = "Test Box";
            document.getElementById('tagDivForReferenceTag').innerHTML =
                    "Reference Colour";
        }

        /**
         * Draw the analyzeScreenPixel GUI on the screen.<p>
         *
         * If the GUI was already visible, this hides the old GUI first.
         *
         * @param {integer} posx The X coordinates of the pixel that is being
         *                       analyzed
         * @param {integer} posy The X coordinates of the pixel that is being
         *                       analyzed
         * @param {string} colour The expected colour, as a CSS colour string
         * @param {Object} screenSize The screen size obtained from
         *         analyse_pixel_gui.getScreenSize().  Caller must check that
         *         return value for null before passing it in here.
         * @alias Internal.analyse_pixel_gui.show
         */
        function show(posx, posy, colour, screenSize) {
            var width = screenSize.width;
            var height = screenSize.height;

            // Now posx / posy / width / height have all been validated.
            // items required on set-up, as object properties:
            // 1) a sample screen colour block, plus comment - place in greater
            //    half
            // 2) crosshairs
            hide();
            var outerDiv = createDiv(document.body,
                                     0, 0,
                                     width, height,
                                     "transparent", false);
            outerDiv.setAttribute("id", "outerDiv");

            // create semi-transparent background to reduce distractions
            var bgcol = "#c0c0c0";
            // create semi-transparent background left of test pixel box
            createDiv(outerDiv,
                      0, 0,
                      posx - 4, height,
                      bgcol, true);
            // create semi-transparent background right of test pixel box
            createDiv(outerDiv,
                      posx + 5, 0,
                      width, height,
                      bgcol, true);
            // create semi-transparent background extending above test pixel box
            createDiv(outerDiv,
                      posx - 4, 0,
                      posx + 5, posy - 5,
                      bgcol, true);
            // create semi-transparent background extending below test pixel box
            createDiv(outerDiv,
                      posx - 4, posy + 5,
                      posx + 5, height,
                      bgcol, true);

            // create the on screen boxes and text
            createSampleDiv(outerDiv, posx, posy, width, height, colour);
        }

        /**
         * Determine the width and height of the graphics plane.<p>
         *
         * Used to size the GUI and to check the values of posX and posY
         * passed to analyzeScreenPixel.
         *
         * @returns {?Object} An object containing "height" and "width" numeric
         *                    values, or null if the graphics resolution cannot
         *                    be determined.
         * @alias Internal.analyse_pixel_gui.getScreenSize
         */
        function getScreenSize() {
            // There are multiple ways of determining the screen size. Try the
            // specification-specific ones before any others. Some
            // implementations might not conform to the CE-HTML specification
            // (yet), and we need to cater to those too.
            var width, height;

            if (typeof window === 'object' && window !== null && window !== undefined) {
                if (typeof window.height === 'number' &&
                        typeof window.width === 'number') {
                    // These should exist as aliases of innerWidth/innerHeight
                    // as part of CEA-2014-A.
                    height = window.height;
                    width = window.width;
                } else if (typeof window.innerHeight === 'number' &&
                           typeof window.innerWidth === 'number') {
                    // Should be supported as part of CEA-2014-A
                    height = window.innerHeight;
                    width = window.innerWidth;
                } else if (typeof window.screen === 'object') {
                    if (typeof window.screen.availHeight === 'number' &&
                            typeof window.screen.availWidth === 'number') {
                        height = window.screen.availHeight;
                        width = window.screen.availWidth;
                    }
                }
            } else if (typeof document === 'object' && document !== null && document !== undefined) {
                if (typeof document.body === 'object') {
                    if (typeof document.body.clientHeight === 'number' &&
                            typeof document.body.clientWidth === 'number') {
                        height = document.body.clientHeight;
                        width = document.body.clientWidth;
                    }
                } else if (typeof document.documentElement === 'object') {
                    if (typeof document.documentElement.clientHeight ===
                            'number' &&
                            typeof document.documentElement.clientWidth ===
                            'number') {
                        height = document.documentElement.clientHeight;
                        width = document.documentElement.clientWidth;
                    }
                }
            } else if (typeof screen === 'object' && screen !== null && screen !== undefined) {
                if (typeof screen.width === 'number' &&
                        typeof screen.height === 'number') {
                    height = screen.height;
                    width = screen.width;
                }
            }
            if (typeof width !== "number" || typeof height !== "number") {
                return null;
            }
            return {height: height, width: width};
        }

        return {show: show, hide: hide, getScreenSize: getScreenSize};
    }());


    // ------------- Private function: postEncode -----------------------------

    /**
     * Encode string for sending as x-www-form-urlencoded
     *
     * @param {string} text Value to encode
     * @returns {string} Encoded value
     * @alias Internal.postEncode
     */
    function postEncode(text) {
        return encodeURIComponent(text).replace(/%20/g, '+');
    }


    // ------------- Private functions: Test cleanup --------------------------

    /**
     * Function to clean up at the end of a test.<p>
     *
     * Called from endTest, failed analyse calls and false reportstep results.
     *
     * Optionally calls the tearDown() function defined in the test case,
     * then removes all DOM1 event listeners and stops all video/broadcast
     * objects and AV Controls.
     *
     * @function
     * @param {boolean} run_test_teardown  Pass true to run the tearDown()
     *         function defined in the test case, if any, or false to skip that
     *         step.
     * @alias Internal.testCleanUp
     */
    var testCleanUp = (function () {

        // Removes all DOM 1 listeners.
        function removeDOM1Listeners() {
            var i, j;
            var null_function = function () {};
            var oipf_object_list = document.getElementsByTagName('object');

            // Create a list of all available OIPF DOM 1 events.
            var oipf_event_list = ['onLowMemory',
                                   'onApplicationLoaded',
                                   'onApplicationUnloaded',
                                   'onDownloadStateChange',
                                   'onDRMMessageResult',
                                   'onNotificationResult',
                                   'onIMSNotification',
                                   'onRegistrationContextUpdate',
                                   'onIncomingMessage',
                                   'onContactStatusChange',
                                   'onNewWatcher',
                                   'onPVREvent',
                                   'onMetadataSearch',
                                   'onMetadataUpdate',
                                   'onfocus',
                                   'onblur',
                                   'onFullScreenChange',
                                   'onChannelChangeError',
                                   'onChannelChangeSucceeded',
                                   'onPlayStateChange',
                                   'onRecordingEvent',
                                   'onPlaySpeedChanged',
                                   'onPlayPositionChanged',
                                   'onProgrammesChanged',
                                   'onParentalRatingChange',
                                   'onParentalRatingError',
                                   'onDRMRightsError'];

            for (i = 0; i < oipf_object_list.length; i += 1) {
                for (j = 0; j < oipf_event_list.length; j += 1) {
                    oipf_object_list[i][oipf_event_list[j]] = null_function;
                }
            }
        }

        // Stops all video/broadcast and AV Control objects
        function stopVideoObjects() {
            var i, j;

            // Create a list all valid OIPF Object types that can cause the RUT
            // not to scan for changes in AIT.
            var video_object_types = ['video/broadcast', 'video/mp4',
                                      'video/mpeg', 'audio/mp4', 'audio/mpeg'];
            var oipf_object_list = document.getElementsByTagName('object');
            for (i = 0; i < oipf_object_list.length; i += 1) {
                for (j = 0; j < video_object_types.length; j += 1) {
                    if (oipf_object_list[i].getAttribute("type") ===
                            video_object_types[j]) {
                        oipf_object_list[i].stop();
                    }
                }
            }
        }

        // The actual testCleanUp implementation
        // See comments above
        return function (run_test_teardown) {
            if (run_test_teardown) {
                try {
                    // Call a tearDown in test case if defined
                    if (typeof window.tearDown === 'function') {
                        window.tearDown();
                    }
                } catch (ignore) {
                    // Exception from tearDown().
                    // Probably does not need to reported to the user.
                }
            }

            try {
                removeDOM1Listeners();
                stopVideoObjects();
            } catch (ignore) {
                // Catch any exceptions that might be caused.
                // Probably does not need to be reported to the user.
            }
        };
    }());


    // ------------- Private class: Communication --------------------------

    /**
     * Class to handle communication with the VM.  Has a queue of
     * XmlHttpRequests and executes them in order.
     *
     * @class
     * @alias Internal.Comms
     */
    function Comms(launch_mode) {
        if (!(this instanceof Comms)) {
            throw new Error("Must use 'new' when constructing a Comms");
        }

        var comms = this;

        // URL constants: misc
        // URL to the server, for use by DSMCC and harness based tests.
        // (For "normal" tests, the server URL is detected based on the URL
        // to the test page, so this constant is not used).
        var gDefaultServerURL = "http://hbbtv1.test";
        // Absolute URL for the special startup XHR
        var gStartupURL = '/a/ligada/test-starting/?';

        /** The current test ID; used in URLs.
         * @type string
         */
        var current_test_id;

        /** The URL to the server, e.g. "http://hbbtv1.test".  No trailing
         * slash.
         * @type string
         */
        var server_url;

        /** The base URL to use for AJAX requests.
         * @type string
         */
        var ajax_root_url;

        /** Set to true when the test ends - either due to an error, or due to
         * successfully reaching the end of the test.
         * @type boolean
         */
        var test_complete = false;

        /** The queue of pending XHR requests
         * @type Array<XhrJob>
         */
        var job_queue = [];

        /** A list of callback functions, to be called when the job_queue
         * becomes empty.
         * @type Array
         */
        var comms_waiters = [];

        /** The current XMLHttpRequest, or null if none.
         * @type ?XMLHttpRequest
         */
        var current_xhr = null;

        // Forward declaration of these functions
        var startupXhrCallback;
        var onXhrReadyStateChange;

        /** Constructor for a class that represents an XHR request on the queue
         * to be sent with HTTP POST.
         *
         * @class
         * @param {string} url The URL to POST to.  Usually relative, and
         *         ajax_root_url will be prepended to it.  Special case:
         *         If is_startup_xhr is true, then this is an absolute URL
         *         (as ajax_root_url has not been set yet)
         * @param {boolean} is_startup_xhr true for the special XHR we do at
         *         startup, false otherwise
         * @param {boolean} fail_test_if_network_down If true, and we detect
         *         the network is down, then the test fails.
         * @param {string} method_name The method name to show to the user when
         *         reporting that the test has failed because the network is
         *         down.  A string.  Ignored if fail_test_if_network_down is
         *         false.
         * @param {function(?XMLHttpRequest)} completion_callback Callback.
         *         The parameter is the XMLHttpRequest instance, or null if the
         *         network is down.
         */
        function XhrJob(url, is_startup_xhr, fail_test_if_network_down,
                        method_name, completion_callback) {
            this.is_startup_xhr = is_startup_xhr;
            this.fail_test_if_network_down = fail_test_if_network_down;
            this.method_name = method_name;

            // When we make a HTTP POST and use the URL parameters, we don't
            // need to put anything in the POST body - an empty body would be
            // fine.  However, that breaks some XMLHttpRequest libraries.
            // In particular, it breaks node.js's XMLHttpRequest library, which
            // is used for harness based tests.  So to avoid that bug, we send
            // a non-empty "POST" body and arrange for the server to ignore it
            // when URL parameters are specified.
            this.req_body = 'x';
            this.completion_callback = completion_callback;

            // Getter for url, that makes it absolute if needed.
            // Note: ajax_root_url might be set after we call the constructor
            // but before we call this getter.
            this.get_url = function () {
                if (is_startup_xhr) {
                    // We know the URL is absolute, don't change it
                    return url;
                }
                // Convert URL to absolute
                assert(ajax_root_url !== undefined,
                       'ajax_root_url !== undefined');
                return ajax_root_url + url;
            };
        }

        /**
         * Constructor for a class that represents an XHR request on the queue
         * to be sent with HTTP POST and a POST body, that should fail if the
         * network is down.
         *
         * @class
         * @param {string} url The URL to POST to.  Usually relative, and
         *         ajax_root_url will be prepended to it.  Special case:
         *         If is_startup_xhr is true, then this is an absolute URL
         *         (as ajax_root_url has not been set yet)
         * @param {string} method_name The method name to show to the user when
         *         reporting that the test has failed because the network is
         *         down.  Ignored if fail_test_if_network_down is false.
         * @param {function(?XMLHttpRequest)} completion_callback Callback to
         *         call when either the request completes, or the request fails
         *         due to the network being down.  The parameter is the
         *         XMLHttpRequest instance, or null if the network is down.
         * @param {string} req_body Data to be sent as body of HTTP POST
         *         request
         */
        function XhrImmediatePostJob(url, method_name, completion_callback, req_body) {
            assert(typeof req_body === 'string', "typeof req_body !== string");

            XhrJob.call(this, url, false, true, method_name, completion_callback);
            this.req_body = req_body;
        }

        /**
         * Handles a network error.<p>
         *
         * Goes through entire job queue, in order.  If there are any queued
         * XHRs that have the "fail test if network down" flag set, then fails
         * that XHR and every XHR that's later than it in the queue, then
         * queues up a final "test failed" message.<p>
         *
         * Otherwise, does nothing.<p>
         *
         * Only called by onXhrReadyStateChange.
         *
         * @param {string} url The URL that failed
         * @param {integer} status The HTTP status code it returned
         */
        function handleNetworkError(url, status) {
            assert(current_xhr !== null, 'current_xhr !== null');

            // Go through entire job queue, in order.  If we find a queued XHR
            // with the "fail test if network down" flag set, then fail that XHR
            // and every XHR that's later than it in the queue.  Then queue up
            // a final "test failed" message.
            var i = 0;
            var forcing_fail = false;
            var method_that_failed;
            while (i < job_queue.length) {
                if (forcing_fail || job_queue[i].fail_test_if_network_down) {
                    if (!forcing_fail) {
                        forcing_fail = true;
                        method_that_failed = job_queue[i].method_name;
                    }
                    job_queue[i].completion_callback(null);
                    job_queue.splice(i, 1);
                } else {
                    i = i + 1;
                }
            }

            if (forcing_fail) {
                comms.makeTestFail("XHR request failed to '" + url +
                                   "' (returned status: " + status +
                                   "). Network may be down. (Method '" +
                                   method_that_failed +
                                   "' not permitted with no network)");
            }
        }

        /**
         * Check there is an XHR running, and if not then start one or call
         * any waitForCommunicationCompleted callbacks.<p>
         *
         * This is called in multiple places:<ul>
         *
         * <li> whenever we add a XHR to the queue
         * <li> whenever we add a waitForCommunicationCompleted listener
         * <li> whenever a XHR completes (unless it failed due to a network
         *      error)
         * <li> by a timer every 5 seconds</ul>
         */
        function ensureXhrRunning() {
            var w;
            if (current_xhr !== null) {
                // Something is already running.
                return;
            }
            if (job_queue.length === 0) {
                // There's nothing to do.  However, if a test called
                // waitForCommunicationCompleted, there might be callbacks we
                // need to call.
                if (comms_waiters.length !== 0) {
                    w = comms_waiters;
                    comms_waiters = [];
                    while (w.length !== 0) {
                        (w.shift())();
                    }
                }
                return;
            }

            var job = job_queue[0];

            // debugPrint('Starting XHR: ' + job.get_url());
            var req = new XMLHttpRequest();
            req.open('POST', job.get_url(), true);
            req.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');

            req.onreadystatechange = function () {
                onXhrReadyStateChange(req, job);
            };
            current_xhr = req;
            req.send(job.req_body);
        }

        /**
         * Called when a XHR changes state.
         *
         * @param {XMLHttpRequest} req The XMLHttpRequest
         * @param {XhrJob} job The XhrJob
         */
        onXhrReadyStateChange = function (req, job) {
            if (req.readyState !== 4) {
                // Not yet finished
                return;
            }

            // There may be new things at the end of the job queue, but we
            // shouldn't have been removed while running.
            assert(current_xhr === req, 'current_xhr === req');
            assert(job_queue.length >= 1, 'job_queue.length >= 1');
            assert(job_queue[0] === job, 'job_queue[0] === job');

            // debugPrint('Done XHR ' + req.status + ': ' + job.get_url());

            // The XMLHttpRequest spec says that req.status should be 0 if
            // the network is down.  However, at least one box returns 502 in
            // that case.  So, for compatibility, we will assume that all
            // status codes we don't recognise are due to network errors.  The
            // status codes we expect are 200 (OK), and 403 (used to signal
            // that the test has failed).  We might also get 404 or 500 errors
            // while developing the test harness.  But a RUT manufacturer who
            // doesn't read the spec might think that 404 is a reasonable value
            // to return if the network is down.  So, we treat 200, 403 and 500
            // as valid statuses, and everything else as "network down".
            if (req.status !== 200 && req.status !== 403 && req.status !== 500) {
                // Network error
                handleNetworkError(job.get_url(), req.status);
                current_xhr = null;
                // In case of network error, we start a timer
                // to trigger the next XHR.
                window.setTimeout(ensureXhrRunning, 5000);
            } else if (job.is_startup_xhr) {
                if (req.status !== 200) {
                    // debugPrint('Done XHR: Startup server Err');
                    // Server error.  Must retry the XHR.
                    // Leave us in the queue, and start a timer to trigger us.
                    // debugPrint('Error doing startup XHR: ' + req.status);
                    current_xhr = null;
                    window.setTimeout(ensureXhrRunning, 5000);
                } else {
                    // Succesful startup XHR.
                    // debugPrint('Done XHR: Startup OK');
                    // Must call completion callback first, before we run
                    // any other jobs.
                    if (startupXhrCallback(req)) {
                        // Success. Remove from queue and start the next job.
                        job_queue.shift();
                        current_xhr = null;
                        ensureXhrRunning();
                    }
                    // else error; don't start any more XHRs.  Leave the
                    // completed XHR as the current_xhr, so the queue is jammed
                    // and no more XHRs can start.
                }
            } else {
                // debugPrint('Done XHR: Good');
                // Done, remove from queue and start the next job.
                job_queue.shift();
                current_xhr = null;
                ensureXhrRunning();

                job.completion_callback(req);
            }
        };

        /**
         * Process the application/json response from an API call, do logging
         * as appropriate, and call appropriate callback if defined. If
         * request object is null does nothing.<p>
         *
         * true_callback is called if the API request succeeded (TRUEY), and is
         * passed the 'data' part of the decoded JSON data as its only argument.
         * (I.e. this is the data returned by the corresponding Python code,
         * it does NOT include the wrapper object that holds the success/fail
         * indication).<p>
         *
         * false_callback is called if the requested analysis failed (FALSE)<p>
         *
         * In the event the server returns an error (ERROR), no callback is
         * called.
         *
         * @param {?XmlHttpRequest} req The completed XHR, or null if network
         *         is down.
         * @param {function(Object)} true_callback
         * @param {function()} false_callback
         */
        function processApiResponse(req, true_callback, false_callback) {
            var response;
            if (req === null) {
                // network down
                return;
            }

            if (req.status !== 200) {
                // This is likely a server error
                debugPrint("Server communicaton failed with code " + req.status);
                return;
            }
            try {
                response = parseJsonDict(req.responseText);
            } catch (ex) {
                debugPrint('Operation failed: server returned incorrectly formatted response');
                debugPrint("Parse error was: " + ex);
                return;
            }

            // API call succeeded, returned True:
            // (Once upon a time this was a fixed-length format, hence the value
            // "TRUEY" which is the same length as "FALSE").
            if (response.type === 'TRUEY') {
                if (true_callback) {
                    true_callback(response.data);
                }
            // API call succeeded, returned False:
            } else if (response.type === 'FALSE') {
                if (response.msg) {
                    debugPrint('Analysis failed: ' + response.msg);
                } else {
                    debugPrint('Analysis failed');
                }
                debugPrint("Test Failed");
                if (false_callback) {
                    false_callback();
                }
            // API call errored
            } else if (response.type === 'ERROR') {
                if (response.msg) {
                    debugPrint('Ligada iSuite Error: ' + response.msg);
                } else {
                    debugPrint('Error occured during server operation');
                }
            // Unintelligible API response
            } else {
                debugPrint('Operation failed: server returned incorrectly formatted response');
            }
        }

        /** Add a "report" XHR to the job queue.<p>
         *
         * This is used for reportStepResult, reportMessage and endTest, which
         * absolutely must get through even if the network is down.  If there's
         * no network, we'll keep retrying.
         *
         * @param {string} url URL to access, relative to the standard base URL.
         */
        this.queueReportXhr = function (url) {
            function completionCallback(req) {
                processApiResponse(req);
            }
            job_queue.push(new XhrJob(url, false, false, '', completionCallback));
            ensureXhrRunning();
        };

        /** Force the test to fail.  Used when a test does something that's
         * forbidden by the HbbTV test spec.
         *
         * @param {string} reason Human-readable error message
         */
        this.makeTestFail = function (reason) {
            var msg = reason.toString();
            debugPrint("Test FAILED: " + msg);
            comms.queueReportXhr(URLS.makeTestFail +
                                 'comment=' + encodeURIComponent(msg));
        };

        /** Add an "immediate" XHR to the job queue to be sent with HTTP POST.
         * This kind of job does not wait for the network to come back up - if
         * there's no network, it just fails the entire test and automatically
         * calls makeTestFail (i.e. the caller does not need to explicitly fail
         * the test if the 'req' parameter passed to its callback is null).
         *
         * @param {string} url URL to access, relative to the standard base URL.
         * @param {string} method_name The method name to show to the user when
         *         reporting that the test has failed because the network is
         *         down.
         * @param {function(?XMLHttpRequest)} completion_callback Callback to
         *         call when either the request completes, or the request fails
         *         due to the network being down.  The parameter is the
         *         XMLHttpRequest instance, or null if the network is down.
         */
        this.queueImmediateXhr = function (url, method_name,
                                           completion_callback) {
            job_queue.push(new XhrJob(url, false, true, method_name,
                                      completion_callback));
            ensureXhrRunning();
        };

        /** Add an "immediate" XHR to the job queue to be sent with HTTP POST.
         * This kind of job does not wait for the network to come back up - if
         * there's no network, it just fails the entire test and automatically
         * calls makeTestFail (i.e. the caller does not need to explicitly fail
         * the test if the 'req' parameter passed to its callback is null).
         *
         * @param {string} url URL to access, relative to the standard base URL.
         * @param {string} method_name The method name to show to the user when
         *         reporting that the test has failed because the network is
         *         down.
         * @param {string} req_body Data to be sent as body of HTTP POST
         *         request
         * @param {function(?XMLHttpRequest)} completion_callback Callback to
         *         call when either the request completes, or the request fails
         *         due to the network being down.  The parameter is the
         *         XMLHttpRequest instance, or null if the network is down.
         */
        function queueImmediatePostXhr(url, method_name, completion_callback,
                                       req_body) {
            job_queue.push(new XhrImmediatePostJob(url, method_name,
                                      completion_callback, req_body));
            ensureXhrRunning();
        }

        /** Callback for the special startup XHR.
         *
         * @param {XMLHttpRequest} req The XMLHttpRequest instance, which will
         *         have completed the request and got a 200 HTTP status code.
         * @returns {boolean} true on success, or false on error.  An error
         *           return here is unrecoverable - no further communications
         *           with the server is possible.
         */
        startupXhrCallback = function (req) {
            var response;
            assert(req !== null,
                   'Startup XHR should have retried automatically');
            assert(req.status === 200, 'Bad status, ' +
                   'Startup XHR should have retried automatically');

            try {
                response = parseJsonDict(req.responseText);
            } catch (ex) {
                debugPrint('Startup failed: server returned incorrectly ' +
                           'formatted response');
                debugPrint("Parse error was: " + ex);
                // Cannot kill application as we don't know if we were launched
                // from a.aa or not.
                return false;
            }

            launch_mode.is_run_from_launcher = response.from_a_aa;

            if (!response.test_id) {
                debugPrint('Startup failed: server reports no test should ' +
                           'be running');
                // If this is a HbbTV style app, do nothing.  We will be
                // killed by an AIT change soon.  Similarly for a harness
                // based test, we do nothing as we will be killed by "kill -9"
                // soon.
                if (launch_mode.is_run_from_launcher) {
                    // OIPF style app.  Redirect to launcher site after a
                    // short delay (to give the user time to read the
                    // debug message).
                    window.setTimeout(function () {
                        destroyApplication(launch_mode);
                    }, 2000);
                }
                return false;
            }

            // For now, use current test ID if set, in preference to the one
            // sent by the server.  In future should probably check if the
            // test IDs are different and flag an error in this case.
            if (!current_test_id) {
                current_test_id = response.test_id;
            }
            // current_test_run_id = response.run_id;
            ajax_root_url = server_url + "/a/ligada/tests/" +
                current_test_id + "/";

            //var msg = 'Connected to server.  Test ' + current_test_id +
            //           ', run ID ' + current_test_run_id;
            //if (launch_mode.is_run_from_launcher) {
            //    msg = msg + ', launched from a.aa launcher';
            //} else if (launch_mode.is_harness_application) {
            //    msg = msg + ', harness based';
            //} else {
            //    msg = msg + ', launched from AIT';
            //}
            //debugPrint(msg);

            // Start watchdog timer
            startWatchdog(launch_mode, ajax_root_url);
            return true;
        };

        /** Add the special startup XHR to the queue.  This is always called
         * during startup.<p>
         *
         * While the special startup XHR is running, it is always the first XHR
         * in the job queue.
         */
        function queueStartupXhr() {
            var job;
            var protocol = window.location.protocol.replace(':', '');
            var url = server_url + gStartupURL + 'protocol=' + encodeURIComponent(protocol);
            if (current_test_id) {
                url = url + '&test_id=' + encodeURIComponent(current_test_id);
            }
            //debugPrint('Connecting to server... (' + url + ')');
            job = new XhrJob(url, true, false, '', startupXhrCallback);
            job_queue.push(job);
            ensureXhrRunning();
        }

        /** Check if a hostname is a hostname for the test harness.
         *
         * @param {string} h A hostname
         * @return {boolean} true if and only if the hostname is one
         *          of the known aliases for the test harness.
         */
        function isTestHarnessHost(h) {
            return (h === "hbbtv1.test" || h === "hbbtv1.test." ||
                h === "hbbtv2.test" || h === "hbbtv2.test." ||
                h === "hbbtv3.test" || h === "hbbtv3.test." ||
                h === "a.hbbtv1.test" || h === "a.hbbtv1.test." ||
                h === "b.hbbtv1.test" || h === "b.hbbtv1.test." ||
                h === "c.hbbtv1.test" || h === "c.hbbtv1.test.");
        }

        /** For tests launched from HTTP, parse the test ID out of the URL.
         *
         * @param {Location} loc The URL the test was loaded from,
         *         typically <code>window.location</code>.
         * @return {string|undefined} The test ID, or <code>undefined</code>
         *         if the URL does not refer to a file in the testcase
         *         folder.
         */
        function extractTestIdFromLocation(loc) {
            var slash_index;
            var expected_prefix = "/_TESTSUITE/TESTS/";
            var s = loc.pathname;

            if (s.substr(0, expected_prefix.length) !== expected_prefix) {
                // Test not launched from /_TESTSUITE/TESTS/
                // (Maybe running out of RES/ ?)
                return undefined;
            }

            s = s.substr(expected_prefix.length);
            slash_index = s.indexOf("/");
            if (slash_index !== -1) {
                s = s.substr(0, slash_index);
            }
            if (s.length === 0) {
                return undefined;
            }
            return s;
        }

        /** Initial setup step.
         * Sets server_url and kicks off an XHR that will set ajax_root_url.
         */
        this.initialize = function () {
            if (window.location.protocol.replace(':', '') === "http" &&
                    isTestHarnessHost(window.location.host)) {
                // App launched from test harness web server
                current_test_id = extractTestIdFromLocation(window.location);
                server_url = "http://" + window.location.host;
            } else {
                // App launched from DSMCC, or harness based test, or
                // app launched from HTTP/HTTPS server on Internet
                //
                // (Note: If launched from a server on the Internet, this may not
                // work on HbbTV 1.0 terminals, as they do not have to support
                // CORS.  But it will work for HbbTV 1.5 and 2.0 terminals.
                // HbbTV 1.5 terminals must implement the relevant errata.)
                server_url = gDefaultServerURL;
            }
            queueStartupXhr();
        };

        /** Adds a XHR request to the queue using URL parameters.<p>
         *
         * If the request fails with an error or false then no callbacks are
         * made.
         *
         * @param {string} url The URL to retrieve.  A relative URL.
         *         ajax_root_url will be prepended to it.
         * @param {?function(Object)} callback If present it is a function that
         *         will be called after the HTTP request has successfully
         *         completed.  Passed one parameter: The data recieved as part
         *         of the JSON response from the server.  Note that this is
         *         JUST the 'data' part, not the outer object that has the
         *         success/fail flag.  (If the function is called then you
         *         know that the outer object indicated success).
         */
        this.queueSimpleXhr = function (url, method_name, callback) {
            function cb(req) {
                processApiResponse(req, callback);
            }
            comms.queueImmediateXhr(url, method_name, cb);
        };

        /** Adds a XHR request to the queue with data in a POST body.<p>
         *
         * If the request fails with an error or false then no callbacks are
         * made.
         *
         * @param {string} url The URL to retrieve.  A relative URL.
         *         ajax_root_url will be prepended to it.
         * @param {?function(Object)} callback If present it is a function that
         *         will be called after the HTTP request has successfully
         *         completed.  Passed one parameter: The data recieved as part
         *         of the JSON response from the server.  Note that this is
         *         JUST the 'data' part, not the outer object that has the
         *         success/fail flag.  (If the function is called then you
         *         know that the outer object indicated success).
         * @param {string} req_body Data to be sent as body of HTTP POST
         *         request
         */
        this.queueSimplePostXhr = function (url, method_name, callback,
                                            req_body) {
            function cb(req) {
                processApiResponse(req, callback);
            }
            queueImmediatePostXhr(url, method_name, cb, req_body);
        };

        /**
         * Called when the harness reports that an analyse step has failed.
         * Marks the test as complete and tears everything down.
         */
        function analyseCompleteFalseCallback() {
            test_complete = true;
            testCleanUp(true);
        }

        /** This queues an XHR to be sent to the server, typically for an
         * analysis step.  If the network is down, then the test case will
         * fail.<p>
         *
         * When the request completes in any way (i.e. a response is recieved,
         * or the network is determined to be down, or if the test is already
         * complete then immediately), then the specified hook function (if
         * any) will be called with no parameters.  This is intended for
         * cleanup that always has to be done.  E.g. this is used by
         * analyzeScreenPixel to remove the on-screen overlay.<p>
         *
         * If a response is recieved, and it is false (FALSE), then the test
         * case is marked as failed and torn down.<p>
         *
         * If a response is recieved, and it is true (TRUEY), then the
         * specified callback is called with no arguments.<p>
         *
         * If the test has already failed when this function is called then the
         * callback is called with no arguments.
         *
         * @param {string} url The URL to retrieve.  A relative URL.
         *         ajax_root_url will be prepended to it.
         * @param {?function()} callback If present it is a function that
         *         will be called after the HTTP request has successfully
         *         completed.
         * @param {?function()} hook If present it is a function that
         *         will be called after the request has completed in any way,
         *         before the callback is called.
         */
        this.executeAnalyseStep = function (url, callback, hook) {
            if (test_complete) {
                if (hook) {
                    hook();
                }
                callback();
                return;
            }
            function analyseCompleteTrueCallback() {
                callback();
            }
            function analyseCompleteCallback(req) {
                if (hook) {
                    hook();
                }

                processApiResponse(req, analyseCompleteTrueCallback,
                                   analyseCompleteFalseCallback);
            }
            comms.queueImmediateXhr(url, 'Analyse', analyseCompleteCallback);
        };

        /** Check if the test has already completed
         *
         * @returns {boolean} true if the test has already completed
         */
        this.isTestComplete = function () {
            return test_complete;
        };

        /** Mark the test as completed now.
         */
        this.markTestComplete = function () {
            test_complete = true;
        };

        /** Add a callback to be called when all queued communications have
         * completed.<p>
         *
         * If no communications are in progress then the callback will be
         * called immediately.
         *
         * @param {function()} callback Function to be called when all
         *         communications have completed.
         */
        this.addCommCompleteCallback = function (callback) {
            comms_waiters.push(callback);
            ensureXhrRunning();
        };
    }


    // ------------ CI+ API class --------------------------------------------

    /**
     * Class that implements the HbbTVTestApi.cicam public API.
     *
     * @class
     * @param {Comms} comms The Comms instance.
     * @alias Internal.CicamAPI
     */
    function CicamAPI(comms) {
        /**
         */
        this.setScramblingEnabled = function (enabled, callback, callbackObject) {
            var vo = new ValidateObject('cicam.setScramblingEnabled');

            try {
                vo.objectIsBoolean(enabled, 'enabled');
                vo.objectIsFunctionOrFalsy(callback, 'callback');
            } catch (ex) {
                comms.makeTestFail(ex);
                return;
            }

            comms.queueSimpleXhr(URLS.cicamSetScramblingEnabled +
                                 'enabled=' + enabled,
                                 'cicam.setScramblingEnabled',
                                 wrapCallback(callback, callbackObject));
        };

        /**
         */
        this.sendReply = function (oipf_status, oipf_ca_vendor_specific_information,
                                   ca_system_id, callback, callbackObject) {
            var vo = new ValidateObject('cicam.sendReply');
            var ocvsi_null = 'false';

            try {
                vo.objectIsIntegerInRange(oipf_status, 0, 0xFF, 'oipf_status');
                if (oipf_ca_vendor_specific_information !== null) {
                    oipf_ca_vendor_specific_information =
                        vo.convertStringToPrimitive(oipf_ca_vendor_specific_information);
                    vo.objectIsHexBinaryString(oipf_ca_vendor_specific_information,
                        'oipf_ca_vendor_specific_information');
                    vo.objectIsStringLengthInRange(oipf_ca_vendor_specific_information,
                        0, 65000 * 2, 'oipf_ca_vendor_specific_information');
                }
                vo.objectIsIntegerInRange(ca_system_id, 0, 0xFFFF, 'ca_system_id');
                vo.objectIsFunctionOrFalsy(callback, 'callback');
            } catch (ex) {
                comms.makeTestFail(ex);
                return;
            }

            if (oipf_ca_vendor_specific_information === null) {
                ocvsi_null = 'true';
                oipf_ca_vendor_specific_information = "";
            }

            var data = 'status=' + oipf_status +
                '&ocvsi=' + postEncode(oipf_ca_vendor_specific_information) +
                '&ocvsi_null=' + ocvsi_null +
                '&casid=' + ca_system_id;

            comms.queueSimplePostXhr(URLS.cicamSendReply, 'cicam.sendReply',
                                     wrapCallback(callback, callbackObject),
                                     data);
        };

        /**
         */
        this.sendParentalControlInfo = function (oipf_access_status, oipf_rating_type,
            oipf_rating_value, oipf_country_code, oipf_control_url, ca_system_id,
            callback, callbackObject) {
            var vo = new ValidateObject('cicam.sendParentalControlInfo');
            var encoded_oipf_country_code = "";
            var oipf_control_url_null;
            var i;

            try {
                vo.objectIsIntegerInRange(oipf_access_status, 0, 1, 'oipf_access_status');
                vo.objectIsIntegerInRange(oipf_rating_type, 0, 0xFF, 'oipf_rating_type');
                vo.objectIsIntegerInRange(oipf_rating_value, 0, 0xFF, 'oipf_rating_value');
                vo.objectIsNullOrIntArray(oipf_country_code, 0, 0xFFFF, 'oipf_country_code');
                vo.objectIsNullOrString(oipf_control_url, 'oipf_control_url');
                vo.objectIsIntegerInRange(ca_system_id, 0, 0xFFFF, 'ca_system_id');
                vo.objectIsFunctionOrFalsy(callback, 'callback');
            } catch (ex) {
                comms.makeTestFail(ex);
                return;
            }

            // Encode as CSV (with trailing comma)
            if (oipf_country_code !== null) {
                for (i = 0; i < oipf_country_code.length; i += 1) {
                    encoded_oipf_country_code += oipf_country_code[i] + "%2C";
                }
            }

            oipf_control_url_null = (oipf_control_url === null) ? 'true' : 'false';

            comms.queueSimpleXhr(URLS.cicamSendParentalControlInfo +
                    'access_status=' + oipf_access_status +
                    '&rating_type=' + oipf_rating_type +
                    '&rating_value=' + oipf_rating_value +
                    '&country_code=' + encoded_oipf_country_code +
                    '&control_url=' + encodeURIComponent(oipf_control_url) +
                    '&control_url_null=' + oipf_control_url_null +
                    '&casid=' + ca_system_id,
                    'cicam.sendParentalControlInfo',
                    wrapCallback(callback, callbackObject));
        };

        /**
         */
        this.sendRightsInfo = function (oipf_access_status, oipf_rights_issuer_url,
            ca_system_id, callback, callbackObject) {
            var vo = new ValidateObject('cicam.sendRightsInfo');
            var oipf_rights_issuer_url_null;

            try {
                vo.objectIsIntegerInRange(oipf_access_status, 0, 1, 'oipf_access_status');
                vo.objectIsNullOrString(oipf_rights_issuer_url, 'oipf_rights_issuer_url');
                vo.objectIsIntegerInRange(ca_system_id, 0, 0xFFFF, 'ca_system_id');
                vo.objectIsFunctionOrFalsy(callback, 'callback');
            } catch (ex) {
                comms.makeTestFail(ex);
                return;
            }

            oipf_rights_issuer_url_null = (oipf_rights_issuer_url === null) ? 'true' : 'false';

            comms.queueSimpleXhr(URLS.cicamSendRightsInfo +
                    'access_status=' + oipf_access_status +
                    '&rights_issuer_url=' + encodeURIComponent(oipf_rights_issuer_url) +
                    '&rights_issuer_url_null=' + encodeURIComponent(oipf_rights_issuer_url_null) +
                    '&casid=' + ca_system_id,
                    'cicam.sendRightsInfo',
                    wrapCallback(callback, callbackObject));
        };

        /**
         */
        this.sendSystemInfo = function (oipf_ca_vendor_specific_information,
                                        ca_system_id, callback, callbackObject) {
            var vo = new ValidateObject('cicam.sendSystemInfo');

            try {
                oipf_ca_vendor_specific_information =
                    vo.convertStringToPrimitive(oipf_ca_vendor_specific_information);
                vo.objectIsHexBinaryString(oipf_ca_vendor_specific_information,
                    'oipf_ca_vendor_specific_information');
                vo.objectIsStringLengthInRange(oipf_ca_vendor_specific_information,
                    0, 65000 * 2, 'oipf_ca_vendor_specific_information');
                vo.objectIsIntegerInRange(ca_system_id, 0, 0xFFFF, 'ca_system_id');
                vo.objectIsFunctionOrFalsy(callback, 'callback');
            } catch (ex) {
                comms.makeTestFail(ex);
                return;
            }

            var data = 'ocvsi=' +
                postEncode(oipf_ca_vendor_specific_information) +
                '&casid=' + ca_system_id;

            comms.queueSimplePostXhr(URLS.cicamSendSystemInfo,
                                     'cicam.sendSystemInfo',
                                     wrapCallback(callback, callbackObject),
                                     data);
        };

        /**
         */
        this.clearAuthentication = function (callback, callbackObject) {
            var vo = new ValidateObject('cicam.clearAuthentication');

            try {
                vo.objectIsFunctionOrFalsy(callback, 'callback');
            } catch (ex) {
                comms.makeTestFail(ex);
                return;
            }

            comms.queueSimpleXhr(URLS.cicamClearAuthentication,
                                 'cicam.clearAuthentication',
                                 wrapCallback(callback, callbackObject));
        };

        /**
         */
        this.sendURI = function (uri, callback, callbackObject) {
            var vo = new ValidateObject('cicam.sendURI');

            try {
                uri = vo.convertStringToPrimitive(uri);
                vo.objectIsHexBinaryString(uri, 'uri', 8);
                vo.objectIsStringLengthInRange(uri, 8 * 2, 8 * 2, 'uri');
                vo.objectIsFunctionOrFalsy(callback, 'callback');
            } catch (ex) {
                comms.makeTestFail(ex);
                return;
            }

            comms.queueSimpleXhr(URLS.cicamSendUri +
                                 'uri=' + encodeURIComponent(uri),
                                 'cicam.sendURI',
                                 wrapCallback(callback, callbackObject));
        };

        /**
         */
        this.waitForMessage = function (timeout, oipf_status,
            oipf_ca_vendor_specific_information, ca_system_id,
            callback, callbackObject) {

            var vo = new ValidateObject('cicam.waitForMessage');
            var send_reply_msg = (oipf_status !== null);
            var ocvsi_null = 'false';

            try {
                vo.objectIsIntegerInRange(timeout, 1, 300000, 'timeout');
                // Parameters only validated if used:
                if (send_reply_msg) {
                    vo.objectIsIntegerInRange(oipf_status, 0, 0xFF, 'oipf_status');
                    if (oipf_ca_vendor_specific_information !== null) {
                        oipf_ca_vendor_specific_information =
                            vo.convertStringToPrimitive(oipf_ca_vendor_specific_information);
                        vo.objectIsHexBinaryString(oipf_ca_vendor_specific_information,
                            'oipf_ca_vendor_specific_information');
                        vo.objectIsStringLengthInRange(oipf_ca_vendor_specific_information,
                            0, 65000 * 2, 'oipf_ca_vendor_specific_information');
                    }
                    vo.objectIsIntegerInRange(ca_system_id, 0, 0xFFFF, 'ca_system_id');
                } else {
                    // No return message data set, force valid values
                    // (won't be used by server after type checks):
                    oipf_status = 1;
                    oipf_ca_vendor_specific_information = null;
                    ca_system_id = 1;
                }
                vo.objectIsFunctionOrFalsy(callback, 'callback');
            } catch (ex) {
                comms.makeTestFail(ex);
                return;
            }

            if (oipf_ca_vendor_specific_information === null) {
                ocvsi_null = 'true';
                oipf_ca_vendor_specific_information = "";
            }

            // -- Queue two XHRs; one to start the operation, one to retrieve
            // the results
            var data = 'timeout=' + timeout +
                '&send_reply_msg=' + send_reply_msg +
                '&status=' + oipf_status +
                '&ocvsi=' + postEncode(oipf_ca_vendor_specific_information) +
                '&ocvsi_null=' + ocvsi_null +
                '&casid=' + ca_system_id;

            // Second XHR (collect result) callbacks
            function waitFinishedCallback(data) {
                if (data && data.timed_out !== true) {
                    callback(2, data, callbackObject);
                } else {
                    callback(3, null, callbackObject);
                }
            }

            // First XHR (start wait) callbacks
            function waitStartedCallback() {
                callback(1, null, callbackObject);
                // Assuming callback completes, launch second XHR to retrieve
                // results:
                comms.queueSimpleXhr(URLS.cicamWaitForMessageEnd,
                                     'cicam.waitForMessage',
                                     waitFinishedCallback);
            }

            // Launch first XHR:
            comms.queueSimplePostXhr(URLS.cicamWaitForMessageStart,
                                     'cicam.waitForMessage',
                                     waitStartedCallback, data);
        };

        /**
         */
        this.runCamScript = function (script, timeout, returnEntireStdout,
                                      callback, callbackObject) {

            var vo = new ValidateObject('cicam.runCamScript');

            try {
                vo.objectIsString(script, 'script');
                vo.objectIsIntegerInRange(timeout, 1, 300000, 'timeout');
                vo.objectIsBoolean(returnEntireStdout, 'returnEntireStdout');
                vo.objectIsFunctionOrFalsy(callback, 'callback');
            } catch (ex) {
                comms.makeTestFail(ex);
                return;
            }

            function camScriptCallback(data) {
                callback(data, callbackObject);
            }

            comms.queueSimpleXhr(URLS.cicamRunScriptGetOutput +
                                 'script=' + script +
                                 '&timeout=' + timeout +
                                 '&return_entire_stdout=' + returnEntireStdout,
                                 'cicam.runCamScript', camScriptCallback);
        };
    }


    // ------------- DIAL API Class ------------------------------------------

    /**
     * Class that implements the HbbTVTestApi.dial public API.<p>
     *
     * The functions in here make XHR POST requests to the Python code
     * which actually handles the DIAL request and response mechanics.<p>
     *
     * NOTE this can make things appear confusing. The HTTP requests and
     * responses dealt with in here, concern our internal interface between
     * the JavaScript code and the Python code. The Python code is *then* doing
     * HTTP requests to the DUT and returning the results of those requests
     * within the JSON data passed back to this JavaScript.
     *
     * @class
     * @param {Comms} comms The Comms instance.
     * @alias Internal.DialTestAPI
     */
    function DialTestAPI(comms) {

        /** Entry point for HbbTVTestAPI.dial.doMSearch()
         *
         * @param {function(Objext, string)} callback Callback function.
         *         Called as
         *         <code>callback(callbackObject, locationHeader)</code>
         * @param {Object} callbackObject
         */
        this.doMSearch = function (callback, callbackObject) {
            // Called with the results of the XHR request
            //
            function doMSearchCb(req) {
                if (req === undefined) {
                    comms.makeTestFail('Error making doMSearch XHR: server returned ' +
                        'incorrectly formatted response');
                    return;
                }
                if (req.location) {
                    // Success
                    checkCallback(callback, callbackObject, req.location);
                } else {
                    // Failed to get the location so force the test to fail and
                    // do not call the callback (as per the Test Spec).
                    var failReason = 'Error making doMSearch XHR: server returned' +
                            ' response without locationHeader';
                    debugPrint(failReason);
                    comms.makeTestFail(failReason);
                }
            }

            var vo = new ValidateObject('dial.doMSearch');
            try {
                vo.objectIsFunctionOrFalsy(callback, 'callback');
            } catch (ex) {
                comms.makeTestFail(ex);
                return;
            }

            // Make a POST request to conduct the M-Search
            comms.queueSimpleXhr(URLS.dialMSearch, 'doMSearch', doMSearchCb);
        };


        /** Entry point for HbbTVTestAPI.dial.getDeviceDescription()
         *
         * @param {string} url
         * @param {?string} origin
         * @param {function(Objext, ?string, bool, ?string)} callback
         *         Callback function.  Called as
         *         <code>callback(callbackObject, applicationUrl,
         *         didRedirect, allowOrigin)</code>
         * @param {Object} callbackObject
         */
        this.getDeviceDescription = function (url, origin, callback, callbackObject) {
            // Called with the results of the XHR request
            //
            function getDeviceDescriptionCb(req) {
                if (req === undefined) {
                    comms.makeTestFail('Error making getDeviceDescription XHR: server returned ' +
                        'incorrectly formatted response');
                    return;
                }
                if (req.did_redirect === undefined) {
                    var failReason = "Error making getDeviceDescription XHR: server returned" +
                            " response without 'didRedirect'";
                    debugPrint(failReason);
                    comms.makeTestFail(failReason);
                } else {
                    var didRedirect = req.did_redirect;
                    var applicationUrl = null;  // default value
                    var allowOrigin = null;     // default value
                    if (req.application_url !== undefined) {
                        applicationUrl = req.application_url;
                    }
                    if (req.allow_origin !== undefined) {
                        allowOrigin = req.allow_origin;
                    }
                    checkCallback(callback, callbackObject, applicationUrl, didRedirect,
                            allowOrigin);
                }
            }

            var vo = new ValidateObject('dial.getDeviceDescription');
            url = vo.convertStringToPrimitive(url);
            origin = vo.convertStringToPrimitive(origin);
            try {
                vo.objectIsString(url, 'url');
                vo.objectIsNullOrString(origin, 'origin');
                vo.objectIsFunctionOrFalsy(callback, 'callback');
            } catch (ex) {
                comms.makeTestFail(ex);
                return;
            }

            var data = 'url=' + url +
                    '&origin=' + origin;

            // Make a POST request to conduct the Get Service Description
            comms.queueSimpleXhr(URLS.dialDeviceDesc + data, 'getDeviceDescription',
                    getDeviceDescriptionCb, data);
        };


        /** Entry point for HbbTVTestAPI.dial.getHbbtvAppDescription()
         *
         * @param {string} applicationUrl
         * @param {boolean} schemaValidation
         * @param {?string} origin
         * @param {function(Objext, ?string, ?string, ?string, ?string)}
         *         callback Callback function.  Called as
         *         <code>callback(callbackObject, app2appUrl, interdevSyncUrl,
         *         userAgent, allowOrigin)</code>
         * @param {Object} callbackObject
         */
        this.getHbbtvAppDescription = function (applicationUrl, schemaValidation,
                origin, callback, callbackObject) {

            // Called with the results of the XHR request
            //
            function getHbbtvAppDescCB(req) {
                if (req === undefined) {
                    comms.makeTestFail('Error making getHbbtvAppDescription XHR: server returned ' +
                        'incorrectly formatted response');
                    return;
                }
                var app2appUrl = null;      // default value
                var interdevSyncUrl = null; // default value
                var userAgent = null;       // default value
                var allowOrigin = null;     // default value
                if (req.app_2_app__url !== undefined) {
                    app2appUrl = req.app_2_app__url;
                }
                if (req.interdev_sync_url !== undefined) {
                    interdevSyncUrl = req.interdev_sync_url;
                }
                if (req.user_agent !== undefined) {
                    userAgent = req.user_agent;
                }
                if (req.allow_origin !== undefined) {
                    allowOrigin = req.allow_origin;
                }
                checkCallback(callback, callbackObject, app2appUrl, interdevSyncUrl,
                        userAgent, allowOrigin);
            }

            var vo = new ValidateObject('getHbbtvAppDescription');
            applicationUrl = vo.convertStringToPrimitive(applicationUrl);
            origin = vo.convertStringToPrimitive(origin);
            try {
                vo.objectIsString(applicationUrl, 'applicationUrl');
                vo.objectIsBoolean(schemaValidation, 'schemaValidation');
                vo.objectIsNullOrString(origin, 'origin');
                vo.objectIsFunctionOrFalsy(callback, 'callback');
            } catch (ex) {
                comms.makeTestFail(ex);
                return;
            }

            // Make a POST request to ask the Python to conduct the options request
            var data = 'app_url=' + postEncode(applicationUrl) +
                    '&schema_valid=' + postEncode(schemaValidation) +
                    '&origin=' + postEncode(origin);
            comms.queueSimpleXhr(URLS.dialHbbtvAppDesc + data, 'getHbbtvAppDescription',
                    getHbbtvAppDescCB, data);
        };


        /** Entry point for HbbTVTestAPI.dial.startHbbTVApp()
         *
         * @param {string} applicationUrl
         * @param {string} pathToAitXml
         * @param {?string} origin
         * @param {function(Objext, int, ?string, ?string, ?string)}
         *         callback Callback function.  Called as
         *         <code>callback(callbackObject, returnCode, contentType,
         *         body, allowOrigin)</code>
         * @param {Object} callbackObject
         */
        this.startHbbtvApp = function (applicationUrl, pathToAitXml, origin,
                callback, callbackObject) {

            // Called with the results of the XHR request
            //
            function startHbbTVAppCB(req) {
                if (req === undefined) {
                    comms.makeTestFail('Error making startHbbtvApp XHR: server returned ' +
                        'incorrectly formatted response');
                    return;
                }
                var contentType = null;     // default value
                var body = null;            // default value
                var allowOrigin = null;     // default value

                // N.B. this should never happen as if there is no response then
                // the test will have already been failed, so if we get here
                // then it is a bug in the implementation
                assert(req.return_code !== undefined);

                var returnCode = req.return_code;
                if (req.content_type !== undefined) {
                    contentType = req.content_type;
                }
                if (req.body !== undefined) {
                    body = req.body;
                }
                if (req.allow_origin !== undefined) {
                    allowOrigin = req.allow_origin;
                }
                checkCallback(callback, callbackObject, returnCode, contentType, body, allowOrigin);
            }

            var vo = new ValidateObject('startHbbtvApp');
            applicationUrl = vo.convertStringToPrimitive(applicationUrl);
            pathToAitXml = vo.convertStringToPrimitive(pathToAitXml);
            origin = vo.convertStringToPrimitive(origin);
            try {
                vo.objectIsString(applicationUrl, 'applicationUrl');
                vo.objectIsString(pathToAitXml, 'pathToAitXml');
                vo.objectIsNullOrString(origin, 'origin');
                vo.objectIsFunctionOrFalsy(callback, 'callback');
            } catch (ex) {
                comms.makeTestFail(ex);
                return;
            }

            // Make a POST request to ask the Python to conduct the options request
            var data = 'app_url=' + postEncode(applicationUrl) +
                    '&path_to_ait_xml=' + postEncode(pathToAitXml) +
                    '&origin=' + postEncode(origin);
            comms.queueSimpleXhr(URLS.dialStartHbbtvApp + data, 'startHbbTVApp',
                    startHbbTVAppCB, data);
        };

        /** Entry point for HbbTVTestAPI.dial.sendOptionsRequest()
         *
         * @param {string} applicationUrl
         * @param {boolean} origin
         * @param {function(Objext, ?string, ?string, ?string, ?string)}
         *         callback Callback function.  Called as
         *         <code>callback(callbackObject, allowOrigin, maxAge,
         *         allowMethods, allowHeaders)</code>
         * @param {Object} callbackObject
         */
        this.sendOptionsRequest = function (applicationUrl, origin, callback, callbackObject) {

            // Called with the results of the XHR request
            //
            function sendOptionsRequestCB(req) {
                if (req === undefined) {
                    comms.makeTestFail('Error making sendOptionsRequest XHR: server returned ' +
                        'incorrectly formatted response');
                    return;
                }
                var allowOrigin = null;     // default value
                var maxAge = null;          // default value
                var allowMethods = null;    // default value
                var allowHeaders = null;    // default value
                if (req.allow_origin !== undefined) {
                    allowOrigin = req.allow_origin;
                }
                if (req.max_age !== undefined) {
                    maxAge = req.max_age;
                }
                if (req.allow_methods !== undefined) {
                    allowMethods = req.allow_methods;
                }
                if (req.allow_headers !== undefined) {
                    allowHeaders = req.allow_headers;
                }
                checkCallback(callback, callbackObject, allowOrigin, maxAge, allowMethods, allowHeaders);
            }

            var vo = new ValidateObject('sendOptionsRequest');
            applicationUrl = vo.convertStringToPrimitive(applicationUrl);
            origin = vo.convertStringToPrimitive(origin);
            try {
                vo.objectIsString(applicationUrl, 'applicationUrl');
                vo.objectIsNullOrString(origin, 'origin');
                vo.objectIsFunctionOrFalsy(callback, 'callback');
            } catch (ex) {
                comms.makeTestFail(ex);
                return;
            }

            // Make a POST request to ask the Python to conduct the options request
            var data = 'app_url=' + postEncode(applicationUrl) +
                    '&origin=' + postEncode(origin);
            comms.queueSimpleXhr(URLS.dialSendOptionsRequest + data, 'sendOptionsRequest',
                    sendOptionsRequestCB);
        };

        /** Entry point for HbbTVTestAPI.dial.resolveIpV4Address()
         *
         * @param {string} hostname
         * @param {function(Object, ?string)} callback Callback function.
         *         Called as
         *         <code>callback(callbackObject, dottedIpv4)</code>
         * @param {Object} callbackObject
         */
        this.resolveIpV4Address = function (hostname, callback, callbackObject) {
            // Called with the results of the XHR request
            //
            function resolveIpV4AddressCB(req) {
                if (req === undefined) {
                    comms.makeTestFail('Error making resolveIpV4Address XHR: server returned ' +
                        'incorrectly formatted response');
                    return;
                }
                var dottedIpv4 = null;  // default value
                if (req.dotted_ipv4 !== undefined) {
                    dottedIpv4 = req.dotted_ipv4;
                }
                checkCallback(callback, callbackObject, dottedIpv4);
            }

            var vo = new ValidateObject('resolveIpV4Address');
            hostname = vo.convertStringToPrimitive(hostname);
            try {
                vo.objectIsString(hostname, 'hostname');
                vo.objectIsFunctionOrFalsy(callback, 'callback');
            } catch (ex) {
                comms.makeTestFail(ex);
                return;
            }

            // Make a POST request to ask the Python to conduct the options request
            var data = 'hostname=' + postEncode(hostname);
            debugPrint('XXX: ' + data);
            comms.queueSimpleXhr(URLS.dialResolveIpV4Address + data, 'resolveIpV4Address',
                    resolveIpV4AddressCB);
        };
    }

    /** -------------- openWebsocket API ----------------------------------
     * Note this HbbTV API is in two parts:
     *     WebsocketClientImpl- describes the individual connections between
     *         the testcase and the DUT (via the python based testing service).
     *     WebsocketManager - describes the single local connection between
     *         testsuite.js and the python based websocket testing service.
     */


    /**
     * WebsocketClientImpl object. One is created for for every HbbTV
     * WebSocket between the Testing Service and the DUT for internal
     * use.
     * @class
     * @param websocketId {integer} id of the hbbtv websocket with the DUT
     * @param comms {Comms} comms The Comms instance.
     * @param propWsOpen {boolean} internal ws with testing service, else null.
     *
     * @alias Internal.WebsocketClientImpl
     */
    function WebsocketClientImpl(websocketId, comms, propWsOpen) {

        /** The ID of this websocket.  This is not part of the
         * documented public API.
         * @private
         */
        this.websocketId = websocketId;

        /** WebsocketClientImpl.sendMessage() as defined in Section 7.7.3
         * of HbbTV Test Spec
         *
         * @param data {string}
         * @param binary {boolean}
         * @param fragments
         */
        this.sendMessage = function (data, binary, fragments) {
            var vo = new ValidateObject('openWebsocket.sendMessage');
            data = vo.convertStringToPrimitive(data);
            if (fragments === undefined) {
                fragments = null;
            }
            try {
                vo.objectIsString(data, 'data');
                vo.objectIsBoolean(binary, 'binary');
                // Note this max is just a large number - it is not
                // specified anywhere
                vo.objectIsNullOrIntArray(fragments, 1, 300000, 'fragments');
            } catch (ex) {
                comms.makeTestFail(ex);
                return;
            }
            var message = {websocketId: websocketId,
                           action: 'sendMessage',
                           data: data,
                           binary: binary,
                           fragments: fragments};
            debugPrint('Sending message to Testing Server to sendMessage' +
                        ' to DUT');
            propWsOpen.send(JSON.stringify(message));
        };

        /** WebsocketClientImpl.sendPing() as defined in Section 7.7.4 of
         * HbbTV Test Spec
         *
         * @param data {string}
         */
        this.sendPing = function (data) {

            var vo = new ValidateObject('openWebsocket.sendPing');
            data = vo.convertStringToPrimitive(data);
            try {
                vo.objectIsString(data, 'data');
            } catch (ex) {
                comms.makeTestFail(ex);
                return;
            }

            var pingMessage = {websocketId: websocketId,
                               action: 'sendPing',
                               data: data};
            debugPrint('Sending message to Testing Server to sendPing' +
                        ' to DUT');
            propWsOpen.send(JSON.stringify(pingMessage));
        };

        /** WebsocketClientImpl.close() as defined in Section 7.7.5 of
         * HbbTV Test Spec
         */
        this.close = function () {

            var closeMessage = {websocketId: websocketId,
                                action: 'close'};
            debugPrint('Sending message to Testing Server to close' +
                        ' WebSocket with DUT');
            propWsOpen.send(JSON.stringify(closeMessage));
        };

        /** WebsocketClientImpl.tcpClose() as defined in Section 7.7.6 of
         * HbbTV Test Spec.
         *
         * @param callback
         */
        this.tcpClose = function (callback) {

            var vo = new ValidateObject('openWebsocket.tcpClose');
            try {
                vo.objectIsFunctionOrFalsy(callback, 'callback');
            } catch (ex) {
                comms.makeTestFail(ex);
                return;
            }

            var tcpCloseMessage = {websocketId: websocketId,
                                   action: 'tcpClose'};
            debugPrint('Sending message to Testing Server to tcpClose' +
                        ' WebSocket with DUT');
            propWsOpen.send(JSON.stringify(tcpCloseMessage));
        };

        // Flag that when true means that the 4 API methods on the
        // WebsocketClient may no longer be called
        this.deactivateMethods = false;

         /**
         * WebsocketClient object. Slimmed down version of
         * WebsocketClientImpl for use by the testcase which just has the
         * 4 methods defined by the API
         * @class
         * @param WebsocketClientImpl - the associated WebsocketClientImpl
         *        object
         * @param comms {Comms} comms The Comms instance.
         *
         * @alias Internal.WebsocketClient
         */
        function WebsocketClient(WebsocketClientImpl, comms) {

            var internalWsClient = WebsocketClientImpl;
            var failMessage = "Method calls on this WebsocketClient " +
                              "object are no longer allowed.";

            this.sendMessage = function() {
                if (internalWsClient.deactivateMethods === true) {
                    comms.makeTestFail(failMessage);
                    return;
                }
                internalWsClient.sendMessage.apply(this, arguments);
            };

            this.sendPing = function() {
                if (internalWsClient.deactivateMethods === true) {
                    comms.makeTestFail(failMessage);
                    return;
                }
                internalWsClient.sendPing.apply(this, arguments);
            };

            this.close = function() {
                if (internalWsClient.deactivateMethods === true) {
                    comms.makeTestFail(failMessage);
                    return;
                }
                internalWsClient.deactivateMethods = true;
                internalWsClient.close.apply(this, arguments);
            };

            this.tcpClose = function(callback, callbackObjectTcp) {
                if (internalWsClient.deactivateMethods === true) {
                    comms.makeTestFail(failMessage);
                    return;
                }
                internalWsClient.deactivateMethods = true;
                // Save callback&obj to WebsocketClientImpl for later use
                internalWsClient.callback = callback;
                internalWsClient.callbackObjectTcp = callbackObjectTcp;
                internalWsClient.tcpClose.apply(this, [callback]);
            };
        }
        this.externalWsClient = new WebsocketClient(this, comms);
    }

    /**
     * WebsocketManager object. Describes the single local connection between
     *         testsuite.js and the python based websocket testing service.
     * @class
     *
     * @alias Internal.WebsocketManager
     */
    function WebsocketManager(WebSocket) {

       /** List of requests to open HbbTV websockets recieved from test case
        * that are waiting to be sent until the proprietary WebSocket to the
        * WebSocket Testing Service (python code) is opened.
        */
        var waitingToOpen = [];

        /** List of HbbTV WebSockets between Testing Service and DUT.
        */
        var hbbtvWs = [];

        /** Proprietary WebSocket connected to the Testing Service.
         */
        var propWsOpen = null;

        /* Called to create new websocket  with the DUT)
         *
         * @param url
         * @param onConnect
         * @param onMessage
         * @param onPong
         * @param onClose
         * @param onFail
         * @param callbackObject
         * @param originHeader
         * @param websocketsExtensionHeader
         */
        function requestOpenConnectionWithDUT(url, onConnect, onMessage, onPong, onClose,
                             onFail, callbackObject, originHeader,
                             websocketsExtensionHeader, comms) {

            // Create new WebsocketClientImpl for HbbTV WebSocket
            var websocketId = hbbtvWs.length + 1;
            var ws = new WebsocketClientImpl(websocketId, comms, propWsOpen);
            ws.onConnect = onConnect;
            ws.onMessage = onMessage;
            ws.onPong = onPong;
            ws.onClose = onClose;
            ws.onFail = onFail;
            ws.callbackObject = callbackObject;
            hbbtvWs.push(ws);

            // Send message to Testing Server
            var openMessage = {
                websocketId: websocketId,
                action: 'openWebsocket',
                url: url,
                originHeader: originHeader,
                websocketsExtensionHeader: websocketsExtensionHeader
            };

            // Note whilst requested  to send a message it is possible that the
            // proprietary ws may not have sent an onopen yet in whilch case
            // log message until onopen recieved.
            try {
                propWsOpen.send(JSON.stringify(openMessage));
                debugPrint('Sending message to Testing Server to openWebSocket ' +
                        'with DUT');
            } catch (ex) {
                waitingToOpen.push({
                    url: url,
                    originHeader: originHeader,
                    onConnect: onConnect,
                    onMessage: onMessage,
                    onPong: onPong,
                    onClose: onClose,
                    onFail: onFail,
                    callbackObject: callbackObject,
                    websocketsExtensionHeader: websocketsExtensionHeader
                });
                hbbtvWs.pop(ws);
            }
        }

       /* Called if the proprietary websocket connection between testsuite.js
        * and the python-based websocket testing service needs to be opened
        * (which needs to happen before any websockets can be created with the
        * DUT)
        *
        * @param url
        * @param onConnect
        * @param onMessage
        * @param onPong
        * @param onClose
        * @param onFail
        * @param callbackObject
        * @param originHeader
        * @param websocketsExtensionHeader
        */
        function newConnectWithTestingService(url, onConnect, onMessage,
                                              onPong, onClose, onFail,
                                              callbackObject,
                                              originHeader,
                                              websocketsExtensionHeader,
                                              comms) {
            // url of the Ligada App2App Testing Service
            var testingServiceUrl = "ws://a.aa:8080/cs-app-to-app/testing-service";
            var connection;

            // Check if DUT (if DUT based test) supports WebSockets API.
            if (typeof WebSocket !== "function") {
                comms.makeTestFail("W3C WebSocket API is not available");
                return;
            }

            try {
                debugPrint('Opening proprietary WebSocket to Testing' +
                            ' Service');
                connection = new WebSocket(testingServiceUrl);
                propWsOpen = connection;
            } catch (ex2) {
                comms.makeTestFail('Error detected in connection to Websocket' +
                                  'Testing Service: ' + ex2);
                return;
            }

            // onopen handler for proprietary WebSocket
            connection.onopen = function () {
                var i;
                debugPrint('Connection to WebSocket Testing Service open.');
                requestOpenConnectionWithDUT(url, onConnect, onMessage, onPong,
                                onClose, onFail, callbackObject, originHeader,
                                websocketsExtensionHeader, comms);

                // Also send any other messages that have been requested
                // between first open request for proprietary websocket and
                // onopen being received.
                debugPrint('Sending ' + waitingToOpen.length.toString() + ' logged messages.');
                for (i = 0; i < waitingToOpen.length; i += 1) {
                    requestOpenConnectionWithDUT(waitingToOpen[i].url,
                                    waitingToOpen[i].onConnect,
                                    waitingToOpen[i].onMessage,
                                    waitingToOpen[i].onPong,
                                    waitingToOpen[i].onClose,
                                    waitingToOpen[i].onFail,
                                    waitingToOpen[i].callbackObject,
                                    waitingToOpen[i].originHeader,
                                    waitingToOpen[i].websocketsExtensionHeader, comms);
                }
                waitingToOpen = [];
            };

            // onclose handler for proprietary WebSocket
            connection.onclose = function () {
                debugPrint('Connection to Websocket Testing service closed.');
                propWsOpen = null;
                hbbtvWs = [];
            };

            // onerror handler for proprietary WebSocket
            connection.onerror = function (error) {
                propWsOpen = null;
                debugPrint('Error detected in connection to Websocket' +
                                'Testing Service: ' + error);
                comms.makeTestFail('Error detected in connection to Websocket' +
                                'Testing Service: ' + error);
            };

            // onmessage handler for proprietary WebSocket
            connection.onmessage = function (e) {
                var message = null;
                var websocket = null;
                try {
                    message = JSON.parse(e.data);
                } catch (ex) {
                    comms.makeTestFail("Error parsing json in message " +
                                       "received from Testing Service: " +
                                       ex);
                    return;
                }
                debugPrint('connection.onmessage e.data: ' + message);

                if (message.action === undefined) {
                    comms.makeTestFail("Message with unknown action" +
                                       " received from the Testing Service.");
                    return;
                }

                if (message.action === 'failTest') {
                    comms.makeTestFail('Fail message received from the Testing ' +
                               'Service: ' + message.reason);
                    return;
                }

                if (message.websocketId === undefined) {
                    comms.makeTestFail("Message with unknown websocketId" +
                                       " received from the Testing Service.");
                    return;
                }

                try {
                    var websocket_list = hbbtvWs.filter(function (obj) {
                        return obj.websocketId === message.websocketId;
                    });
                    websocket = websocket_list[0];
                } catch (ex) {
                    comms.makeTestFail('Error identifying websocket with ' +
                                       'ID from message from the Testing Service');
                    return;
                }
                debugPrint('WebsocketID:' + websocket.websocketId);

                if (message.action === 'onConnect') {
                    debugPrint('HbbTV Websocket to DUT is open.');
                    if (message.websocketExtensionHeader === undefined) {
                        message.websocketExtensionHeader = null;
                    }
                    checkCallback(websocket.onConnect, websocket.callbackObject,
                                 message.websocketExtensionHeader,
                                 websocket.externalWsClient);
                } else if (message.action === 'onPong') {
                    debugPrint('Ping from DUT receieved.');
                    if (message.data === undefined) {
                        comms.makeTestFail('Message with unknown data ' +
                                           'received from the Testing Service.');
                        return;
                    }
                    checkCallback(websocket.onPong, websocket.callbackObject,
                                     message.data, websocket.externalWsClient);

                } else if (message.action === 'onMessage') {
                    debugPrint('Message from DUT receieved.');
                    if (message.data === undefined) {
                        comms.makeTestFail('Message with unknown data ' +
                                           'received from the Testing Service.');
                        return;
                    }
                    if (message.binary === undefined) {
                        comms.makeTestFail('Message with unknown binary ' +
                                           'received from the Testing Service.');
                        return;
                    }
                    checkCallback(websocket.onMessage, websocket.callbackObject,
                                     message.data, message.binary,
                                     websocket.externalWsClient);

                } else if (message.action === 'onClose' ||
                           message.action === 'onFail' ||
                           message.action === 'callback') {
                    debugPrint('HbbTV Websocket to DUT message: ' +
                                message.action);
                    // The test may not make any further method calls on the
                    // WebsocketClientImpl - the harness may make further callbacks.
                    websocket.deactivateMethods = true;
                    if (message.action === 'onClose' ||
                            message.action === 'onFail') {
                        if (message.statusCode === undefined) {
                            comms.makeTestFail('Message with unknown statusCode ' +
                                               'received from the Testing Service.');
                            return;
                        }
                        if (message.reason === undefined) {
                            comms.makeTestFail('Message with unknown reason ' +
                                               'received from the Testing Service.');
                            return;
                        }
                        if (message.action === 'onClose') {
                            checkCallback(websocket.onClose, websocket.callbackObject,
                                         message.statusCode,
                                         message.reason,
                                         websocket.externalWsClient);
                        } else {
                            checkCallback(websocket.onFail, websocket.callbackObject,
                                         message.statusCode,
                                         message.reason,
                                         websocket.externalWsClient);
                        }
                    } else {
                        // message is 'callback' aka. is a tcpClose response
                        checkCallback(websocket.callback, websocket.callbackObjectTcp,
                                     websocket.externalWsClient);
                    }
                } else {
                    debugPrint('Unknown message recieved');
                    comms.makeTestFail('Unknown message recieved');
                    return;
                }
            };
        }

        /* Entry point for HbbTVTestAPI.openWebsocket()
         *
         * @param url
         * @param onConnect
         * @param onMessage
         * @param onPong
         * @param onClose
         * @param onFail
         * @param callbackObject
         * @param originHeader
         * @param websocketsExtensionHeader
         */
        this.requestNewWebsocketClient = function(url, onConnect, onMessage,
                                                  onPong, onClose, onFail,
                                                  callbackObject, originHeader,
                                                  websocketsExtensionHeader,
                                                  comms) {

            if (propWsOpen === null) {
                // If not already open, open a proprietary WebSocket to the
                // Testing Service
                newConnectWithTestingService(url, onConnect, onMessage,
                                            onPong, onClose, onFail,
                                            callbackObject,
                                            originHeader,
                                            websocketsExtensionHeader,
                                            comms);
            } else {
                // If proprietary WebSocket to the Testing Service already open,
                // re-use this and instruct Testing Service to open another HbbTV
                // WebSocket
                requestOpenConnectionWithDUT(url, onConnect, onMessage,
                                             onPong, onClose, onFail,
                                             callbackObject, originHeader,
                                             websocketsExtensionHeader,
                                             comms);
            }

        };
    }


    // ------------- Main API Class ------------------------------------------

    /**
     * Class that implements the public API of this file.
     *
     * @class
     * @param {Comms} comms The Comms instance.
     * @alias HbbTVTestAPI
     */
    function HbbTVTestAPI() {
        // Sanity check to catch noncompliant tests that call "x = HbbTVTestAPI()"
        // instead of "x = new HbbTVTestAPI()".
        if (!(this instanceof HbbTVTestAPI)) {
            throw new Error("Must use 'new' when constructing a HbbTVTestAPI");
        }
        // Sanity check to catch noncompliant tests that pass arguments to this
        // function.
        if (arguments.length !== 0) {
            throw new Error("Unexpected arguments passed to HbbTVTestAPI()");
        }

        // ------------- Private variables ------------------------------------

        /** The launch mode of this file - unit test, harness based,
         * DUT based from a.aa, or DUT based from AIT.
         * @type {LaunchMode}
         */
        var launch_mode = new LaunchMode(this);

        /** Handles communication with the VM.  Has a queue of XmlHttpRequests
         * and executes them in order.
         * @type Comms
         */
        var comms = new Comms(launch_mode);

        /** The standard W3C Websockets API. */
        var WebSocket;

        // ------------- Public API functions ---------------------------------

        // ---- APIs Interacting with Test Environment --------------------

        /** Public API function from HbbTV Test Spec 7.2.1.
         *
         * Initialises the test API.  Called once, immediately after creation.
         * ... or maybe not called at all, see Redmine 880.
         */
        this.init = function () {
            // This function must not do anything.  Do not add any code here!
            // Sometimes this function is not called, so any code added here
            // is clearly a bug.  Use the initialisation section for this class
            // instead, at the end of HbbTVTestAPI().
        };

        /** Public API function from HbbTV Test Spec 7.2.4.
         * @param callback
         * @param callbackObject
         */
        this.getPlayoutInformation = function (callback, callbackObject) {
            function playoutInformationCb(req) {
                var info = {}; // Default to the "error occured" value
                if (req === null) {
                    // Network down; this will automatically cause a test failure.
                    debugPrint("Error making getPlayoutInformation XHR: Network down");
                } else if (req.status === 200) {
                    info = {};
                    try {
                        var response = parseJsonDict(req.responseText);
                        if (response.type === "ERROR") {
                            debugPrint('Error making getPlayoutInformation XHR: Server reports an error');
                        } else if (response.type === "FALSE") {
                            debugPrint('Error making getPlayoutInformation XHR: Test is complete');
                        } else if (response.type === "TRUEY" && response.data) {
                            info = response.data;
                        } else {
                            debugPrint('Error making getPlayoutInformation XHR: server returned incorrectly formatted response');
                        }
                    } catch (ex) {
                        debugPrint('Operation failed: server returned incorrectly formatted response');
                        debugPrint("Parse error was: " + ex);
                    }
                } else {
                    debugPrint("Error making getPlayoutInformation XHR: " + req.status);
                }
                if (callback) {
                    callback(callbackObject, info);
                }
            }

            var vo = new ValidateObject('getPlayoutInformation');

            try {
                vo.objectIsFunctionOrFalsy(callback, 'callback');
            } catch (ex) {
                comms.makeTestFail(ex);
                return;
            }

            comms.queueImmediateXhr(URLS.getPlayoutInformation, 'getPlayoutInformation',
                              playoutInformationCb);
        };

        /** Public API function from HbbTV Test Spec 7.2.5.
         */
        this.endTest = function () {
            if (comms.isTestComplete()) {
                return;
            }
            debugPrint('End Of Test');
            comms.queueReportXhr(URLS.endTest);
            // Call the private testCleanUp function to remove all DOM1 events
            // and stop all video objects
            testCleanUp(false);

            comms.markTestComplete();
        };

        /** Public API function from HbbTV Test Spec 7.2.6.
         * @param stepId
         * @param result
         * @param comment
         */
        this.reportStepResult = function (stepId, result, comment) {
            var vo = new ValidateObject('reportStepResult');
            comment = vo.convertStringToPrimitive(comment);
            try {
                vo.objectIsNonNegativeInteger(stepId, 'stepId');
                vo.objectIsBoolean(result, 'result');
                vo.objectIsString(comment, 'comment');
            } catch (ex) {
                comms.makeTestFail(ex);
                return;
            }

            var msg = 'stepid=' + stepId +
                      '&result=' + result +
                      '&comment=' + encodeURIComponent(comment);

            debugPrint('StepID: ' + stepId + ' | ' + 'Result: ' + result +
                       ' | ' + comment);
            if (comms.isTestComplete()) {
                return;
            }
            comms.queueReportXhr(URLS.reportStepResult + msg);

            if (result === false) {
                // server must ignore all further msgs
                comms.markTestComplete();
                // call the private testCleanUp function to remove all event
                // listeners and stop video objects.
                testCleanUp(false);
            }
        };

        /** Public API function from HbbTV Test Spec 7.2.7.
         * @param comment
         */
        this.reportMessage = function (comment) {
            var vo = new ValidateObject('reportMessage');
            comment = vo.convertStringToPrimitive(comment);
            try {
                vo.objectIsString(comment, 'comment');
            } catch (ex) {
                comms.makeTestFail(ex);
                return;
            }

            if (comms.isTestComplete()) {
                return;
            }
            var msg = 'sendMessage=' + encodeURIComponent(comment);
            debugPrint(comment);
            comms.queueReportXhr(URLS.sendMessage + msg);
        };

        /** Public API function from HbbTV Test Spec 7.2.8.
         * @param callback
         * @param callbackObject
         */
        this.waitForCommunicationCompleted = function (callback, callbackObject) {
            var vo = new ValidateObject('waitForCommunicationCompleted');
            try {
                vo.objectIsFunctionOrFalsy(callback, 'callback');
            } catch (ex) {
                comms.makeTestFail(ex);
                return;
            }

            comms.addCommCompleteCallback(wrapCallback(callback, callbackObject));
        };

        /** Public API function from HbbTV Test Spec 7.2.9.
         * @param check
         * @param callback
         * @param callbackObject
         */
        this.manualAction = function (check, callback, callbackObject) {
            var vo = new ValidateObject('manualAction');
            check = vo.convertStringToPrimitive(check);
            try {
                vo.objectIsString(check, 'check');
                vo.objectIsFunctionOrFalsy(callback, 'callback');
            } catch (ex) {
                comms.makeTestFail(ex);
                return;
            }

            comms.executeAnalyseStep(URLS.manualAction +
                               'check=' + encodeURIComponent(check),
                               wrapCallback(callback, callbackObject));
        };

        /** TestAPI.sendPointerCode() as defined in the HbbTV Test Spec.<br>
         * <br>
         * Requests a pointer device to be moved to a location on the screen of
         * the DUT and optionally a pointer code to be sent to the DUT
         *
         * @param {integer} posx The horizontal position of the pixel to move to
         * @param {integer} posy The vertical position of the pixel to move to
         * @param {string} pointerCode Describes the code to send once the pointer
         * is in position
         * @param {function} callback Function to call when the pointer has been
         * moved and any requested pointer code was sent to the DUT
         * @param {Object} callbackObject Object to be passed to all callbacks
         */
        this.sendPointerCode = function (posx, posy, pointerCode, callback,
                                         callbackObject) {
            var vo = new ValidateObject('sendPointerCode');
            pointerCode = vo.convertStringToPrimitive(pointerCode);
            try {
                vo.objectIsIntegerInRange(posx, 0, 1279, 'posx');
                vo.objectIsIntegerInRange(posy, 0, 719, 'posy');
                var validPointerCodes = ['P_CLICK', 'P_DBLCLICK', 'P_DOWN',
                    'P_UP', 'NONE'];
                vo.objectIsStringFromArray(pointerCode, validPointerCodes, 'pointerCode');

                vo.objectIsFunctionOrFalsy(callback, 'callback');
            } catch (ex) {
                comms.makeTestFail(ex);
                return;
            }

            comms.executeAnalyseStep(URLS.sendPointerCode +
                               'posx=' + posx +
                               '&posy=' + posy +
                               '&pointercode=' + encodeURIComponent(pointerCode),
                               wrapCallback(callback, callbackObject));
        };

        /** TestAPI.moveWheel() as defined in the HbbTV Test Spec.<br>
         * <br>
         * Requests the wheel device to be moved relative to the current position.
         *
         * @param {integer} deltax The relative horizontal position to move by
         * @param {integer} deltay The relative vertical position to move by
         * @param {integer} deltaz The relative vertical position to move by
         * @param {string} deltaMode The measurement mode
         * @param {function} callback Function to call when the key code was
         * actually sent to the DUT
         * @param {Object} callbackObject Object to be passed to all callbacks
         */
        this.moveWheel = function (deltax, deltay, deltaz, deltaMode, callback,
                                   callbackObject) {
            var vo = new ValidateObject('moveWheel');
            deltaMode = vo.convertStringToPrimitive(deltaMode);
            try {
                vo.objectIsInteger(deltax);
                vo.objectIsInteger(deltay);
                vo.objectIsInteger(deltaz);
                var validDeltaModes = ['WHEEL_DELTA_PIXEL', 'WHEEL_DELTA_LINE',
                    'WHEEL_DELTA_PAGE'];
                vo.objectIsStringFromArray(deltaMode, validDeltaModes, 'deltaMode');

                vo.objectIsFunctionOrFalsy(callback, 'callback');
            } catch (ex) {
                comms.makeTestFail(ex);
                return;
            }

            comms.executeAnalyseStep(URLS.moveWheel +
                               'deltax=' + deltax +
                               '&deltay=' + deltay +
                               '&deltaz=' + deltaz +
                               '&deltamode=' + encodeURIComponent(deltaMode),
                               wrapCallback(callback, callbackObject));
        };


        // ---- 7.3 APIs Interacting with the Device Under Test ---------------

        /** Public API function from HbbTV Test Spec 7.3.1.
         * @param delaySeconds
         * @param type
         * @param callback
         * @param callbackObject
         */
        this.initiatePowerCycle = function (delaySeconds, type, callback,
                                            callbackObject) {
            var vo = new ValidateObject('initiatePowerCycle');
            type = vo.convertStringToPrimitive(type);
            try {
                vo.objectIsNonNegativeInteger(delaySeconds, 'delaySeconds');
                vo.objectIsStringFromArray(type, ['STANDBY', 'POWERCYCLE'], 'type');
                vo.objectIsFunctionOrFalsy(callback, 'callback');
            } catch (ex) {
                comms.makeTestFail(ex);
                return;
            }

            comms.queueSimpleXhr(URLS.initiatePowerCycle +
                                 'delay=' + delaySeconds +
                                 '&type=' + type, 'initiatePowerCycle',
                                 wrapCallback(callback, callbackObject));
        };

        /** Public API function from HbbTV Test Spec 7.3.2.
         * @param keyCode
         * @param durationSeconds
         * @param callback
         * @param callbackObject
         */
        this.sendKeyCode = function (keyCode, durationSeconds,
                                     callback, callbackObject) {
            var vo = new ValidateObject('sendKeyCode');
            keyCode = vo.convertStringToPrimitive(keyCode);
            try {
                var validKeyCodeList = ['VK_LEFT', 'VK_RIGHT', 'VK_UP', 'VK_DOWN',
                    'VK_ENTER', 'VK_BACK', 'VK_RED', 'VK_GREEN', 'VK_YELLOW',
                    'VK_BLUE', 'VK_0', 'VK_1', 'VK_2', 'VK_3', 'VK_4', 'VK_5',
                    'VK_6', 'VK_7', 'VK_8', 'VK_9', 'VK_PLAY', 'VK_PAUSE',
                    'VK_PLAY_PAUSE', 'VK_STOP', 'VK_FAST_FWD', 'VK_REWIND'];
                vo.objectIsStringFromArray(keyCode, validKeyCodeList, 'keyCode');

                vo.objectIsNonNegativeInteger(durationSeconds, 'durationSeconds');
                vo.objectIsFunctionOrFalsy(callback, 'callback');
            } catch (ex) {
                comms.makeTestFail(ex);
                return;
            }

            comms.queueSimpleXhr(URLS.sendKeyCode + 'keycode=' + keyCode +
                                 '&duration=' + durationSeconds, 'sendKeyCode',
                                 wrapCallback(callback, callbackObject));
        };

        /** Public API function from HbbTV Test Spec 7.3.3.
         * @param stepId
         * @param comment
         * @param posX
         * @param posY
         * @param referenceColor
         * @param callback
         * @param callbackObject
         */
        this.analyzeScreenPixel = function (stepId, comment, posX, posY,
                                            referenceColor, callback,
                                            callbackObject) {
            var cleanupHook;  // Defaults to undefined
            var screenSize;
            var vo = new ValidateObject('analyzeScreenPixel');
            comment = vo.convertStringToPrimitive(comment);
            referenceColor = vo.convertStringToPrimitive(referenceColor);
            try {
                // Perform basic sanity check of arguments.
                vo.objectIsNonNegativeInteger(stepId, 'stepId');
                vo.objectIsString(comment, 'comment');
                vo.objectIsNonNegativeInteger(posX, 'posx');
                vo.objectIsNonNegativeInteger(posY, 'posy');
                vo.objectIsFormattedString(referenceColor, '^#[0-9a-fA-F]{6}$',
                    'referenceColor is a string with value ' + referenceColor +
                    '. This must be a hex string in the form #RRGGBB',
                    'referenceColor');
                vo.objectIsFunctionOrFalsy(callback, 'callback');
            } catch (ex) {
                comms.makeTestFail(ex);
                return;
            }

            // Normally tests are run on the RUT, so we can query the screen size
            // and draw overlays on the screen.
            // But if we're running as a harness based test (i.e. inside the
            // Ligada VM) then we can't do those things, so we skip them.

            if (!launch_mode.is_harness_application || launch_mode.is_unit_test) {
                // Determine the size of the screen the test is being run on in
                // order to verify the posX and posY arguments. The method to
                // obtain the values will vary across HbbTV / OIPF implementations.
                screenSize = analyse_pixel_gui.getScreenSize();
                if (screenSize === null) {
                    comms.makeTestFail("Unable to determine the resolution " +
                                       "of the graphics plane.");
                    return;
                }

                // Check the posX and posY co-ordinates are inside the screen.
                // posX and posy are the co-ordinates of the pixel being checked
                if (posX >= screenSize.width) {
                    comms.makeTestFail("analyseScreenPixel: horizontal " +
                                       "coordinate " + posX + " is outside " +
                                       "the graphics plane.  It should be " +
                                       "less than " + screenSize.width + ".");
                    return;
                }
                if (posY >= screenSize.height) {
                    comms.makeTestFail("analyseScreenPixel: vertical " +
                                       "coordinate " + posY + " is outside " +
                                       "the graphics plane.  It should be " +
                                       "less than " + screenSize.height + ".");
                    return;
                }

                // Draw an overlay on screen to indicate the pixel to be checked
                // and show the expected colour.
                analyse_pixel_gui.show(posX, posY, referenceColor, screenSize);
                cleanupHook = analyse_pixel_gui.hide;
            }
            comms.executeAnalyseStep(URLS.analyseScreenPixel + 'posx=' + posX +
                               '&posy=' + posY +
                               '&colour=' + encodeURIComponent(referenceColor) +
                               '&stepid=' + stepId +
                               '&comment=' + encodeURIComponent(comment) +
                               '&is_harness_app=' + launch_mode.is_harness_application,
                               wrapCallback(callback, callbackObject),
                               cleanupHook);
        };

        /** Public API function from HbbTV Test Spec 7.3.4.
         * @param stepId
         * @param comment
         * @param check
         * @param callback
         * @param callbackObject
         */
        this.analyzeScreenExtended = function (stepId, comment, check, callback,
                                               callbackObject) {
            var vo = new ValidateObject('analyzeScreenExtended');
            comment = vo.convertStringToPrimitive(comment);
            check = vo.convertStringToPrimitive(check);
            try {
                vo.objectIsNonNegativeInteger(stepId, 'stepId');
                vo.objectIsString(comment, 'comment');
                vo.objectIsString(check, 'check');
                vo.objectIsFunctionOrFalsy(callback, 'callback');
            } catch (ex) {
                comms.makeTestFail(ex);
                return;
            }

            comms.executeAnalyseStep(URLS.analyseScreenExtended +
                               'check=' + encodeURIComponent(check) +
                               '&stepid=' + stepId +
                               '&comment=' + encodeURIComponent(comment),
                               wrapCallback(callback, callbackObject));
        };

        /** Public API function from HbbTV Test Spec 7.3.5.
         * @param stepId
         * @param comment
         * @param channelId
         * @param referenceFrequency
         * @param callback
         * @param callbackObject
         */
        this.analyzeAudioFrequency = function (stepId, comment, channelId,
                                               referenceFrequency, callback,
                                               callbackObject) {
            var vo = new ValidateObject('analyzeAudioFrequency');
            comment = vo.convertStringToPrimitive(comment);
            try {
                vo.objectIsNonNegativeInteger(stepId, 'stepId');
                vo.objectIsString(comment, 'comment');
                vo.objectIsIntegerInRange(channelId, 1, 5, 'channelId');
                var frequencies = [500, 630, 800, 1000, 1250, 1600, 2000, 2500,
                                   3150, 4000];
                vo.objectIsIntegerInList(referenceFrequency, frequencies,
                                         'referenceFrequency');

                vo.objectIsFunctionOrFalsy(callback, 'callback');
            } catch (ex) {
                comms.makeTestFail(ex);
                return;
            }

            comms.executeAnalyseStep(URLS.analyseAudioFrequency +
                               'channelid=' + channelId +
                               '&referencefrequency=' + referenceFrequency +
                               '&stepid=' + stepId +
                               '&comment=' + encodeURIComponent(comment),
                               wrapCallback(callback, callbackObject));
        };

        /** Public API function from HbbTV Test Spec 7.3.6.
         * @param stepId
         * @param comment
         * @param check
         * @param callback
         * @param callbackObject
         */
        this.analyzeAudioExtended = function (stepId, comment, check, callback,
                                              callbackObject) {
            var vo = new ValidateObject('analyzeAudioExtended');
            comment = vo.convertStringToPrimitive(comment);
            check = vo.convertStringToPrimitive(check);
            try {
                vo.objectIsNonNegativeInteger(stepId, 'stepId');
                vo.objectIsString(comment, 'comment');
                vo.objectIsString(check, 'check');
                vo.objectIsFunctionOrFalsy(callback, 'callback');
            } catch (ex) {
                comms.makeTestFail(ex);
                return;
            }

            comms.executeAnalyseStep(URLS.analyseAudioExtended +
                               'check=' + encodeURIComponent(check) +
                               '&stepid=' + stepId +
                               '&comment=' + encodeURIComponent(comment),
                               wrapCallback(callback, callbackObject));
        };

        /** Public API function from HbbTV Test Spec 7.3.7.
         * @param stepId
         * @param comment
         * @param check
         * @param callback
         * @param callbackObject
         */
        this.analyzeVideoExtended = function (stepId, comment, check, callback,
                                              callbackObject) {
            var vo = new ValidateObject('analyzeVideoExtended');
            comment = vo.convertStringToPrimitive(comment);
            check = vo.convertStringToPrimitive(check);
            try {
                vo.objectIsNonNegativeInteger(stepId, 'stepId');
                vo.objectIsString(comment, 'comment');
                vo.objectIsString(check, 'check');
                vo.objectIsFunctionOrFalsy(callback, 'callback');
            } catch (ex) {
                comms.makeTestFail(ex);
                return;
            }

            comms.executeAnalyseStep(URLS.analyseVideoExtended +
                               'check=' + encodeURIComponent(check) +
                               '&stepid=' + stepId +
                               '&comment=' + encodeURIComponent(comment),
                               wrapCallback(callback, callbackObject));
        };

        /** Public API function from HbbTV Test Spec 7.3.8.
         * @param stepId
         * @param comment
         * @param check
         * @param callback
         * @param callbackObject
         */
        this.analyzeManual = function (stepId, comment, check, callback,
                                       callbackObject) {
            var vo = new ValidateObject('analyzeManual');
            comment = vo.convertStringToPrimitive(comment);
            check = vo.convertStringToPrimitive(check);
            try {
                vo.objectIsNonNegativeInteger(stepId, 'stepId');
                vo.objectIsString(comment, 'comment');
                vo.objectIsString(check, 'check');
                vo.objectIsFunctionOrFalsy(callback, 'callback');
            } catch (ex) {
                comms.makeTestFail(ex);
                return;
            }

            comms.executeAnalyseStep(URLS.analyseManual +
                               'check=' + encodeURIComponent(check) +
                               '&stepid=' + stepId +
                               '&comment=' + encodeURIComponent(comment),
                               wrapCallback(callback, callbackObject));
        };

        /**
         * This function checks the synchronization between two or three of:
         * video, second video, subtitles, and audio.
         * It is used with video and subtitles streams containing flashes,
         * and audio streams containing tone bursts,
         * as described in section 5.2.1.13.
         *
         * @param {integer} stepId
         * @param {string} comment
         * @param {boolean} checkLight1AgainstAudio
         * @param {boolean} checkLight2AgainstAudio
         * @param {boolean} checkLight1AgainstLight2
         * @param {integer} maxDifferenceMillis
         * @param {function(Object)} callback
         * @param {Object} callbackObject
         */
        this.analyzeAvSync = function (stepId,
                                       comment,
                                       checkLight1AgainstAudio,
                                       checkLight2AgainstAudio,
                                       checkLight1AgainstLight2,
                                       maxDifferenceMillis,
                                       callback,
                                       callbackObject) {

            var vo = new ValidateObject('analyzeAvSync');

            try {
                vo.objectIsNonNegativeInteger(stepId, 'stepId');
                vo.objectIsString(comment, 'comment');
                vo.objectIsBoolean(checkLight1AgainstAudio, 'checkLight1AgainstAudio');
                vo.objectIsBoolean(checkLight2AgainstAudio, 'checkLight2AgainstAudio');
                vo.objectIsBoolean(checkLight1AgainstLight2, 'checkLight1AgainstLight2');
                vo.objectIsNonNegativeInteger(maxDifferenceMillis, 'maxDifferenceMillis');
                vo.objectIsFunctionOrFalsy(callback, 'callback');
            } catch (ex) {
                comms.makeTestFail(ex);
                return;
            }

            comms.executeAnalyseStep(URLS.analyzeAvSync +
                "step_number=" + stepId +
                "&comment=" + encodeURIComponent(comment) +
                "&check_light_1_against_audio=" + checkLight1AgainstAudio +
                "&check_light_2_against_audio=" + checkLight2AgainstAudio +
                "&check_light_1_against_light_2=" + checkLight1AgainstLight2 +
                "&max_difference_millis=" + maxDifferenceMillis,
                wrapCallback(callback, callbackObject));
        };

        /**
         * This function checks the synchronization between
         * graphics and either video or subtitles.
         *
         * @param {integer} stepId
         * @param {string} comment
         * @param {function(Object,
         *         HbbtvTestAPI~analyzeFinishedVideoGraphicsSync)} callback
         * @param {Object} callbackObject
         */
        this.analyzeStartVideoGraphicsSync = function (stepId,
                                                       comment,
                                                       callback,
                                                       callbackObject) {
            var vo = new ValidateObject('analyzeStartVideoGraphicsSync');
            var finishedCalled = false;

            try {
                vo.objectIsNonNegativeInteger(stepId, 'stepId');
                vo.objectIsString(comment, 'comment');
                vo.objectIsFunction(callback, 'callback');
            } catch (ex) {
                comms.makeTestFail(ex);
                return;
            }

            /**
             * The callback function called when analyzeStartVideoGraphicsSync
             * has successfully been called in the python code.
             */
            function analyzeStartVideoGraphicsSyncCb() {

                /**
                 * @callback HbbtvTestAPI~analyzeFinishedVideoGraphicsSync
                 * @param {integer} expectedDeltaMillis
                 * @param {integer} maxDifferenceMillis
                 * @param {function(Object)} callback
                 */
                function analyzeFinishedVideoGraphicsSync(expectedDeltaMillis,
                                                          maxDifferenceMillis,
                                                          callback,
                                                          callbackObject) {
                    if (finishedCalled) {
                        comms.makeTestFail("Error: analyzeFinishedVideoGraphicsSync callback already called");
                        return;
                    }

                    finishedCalled = true;

                    var vo = new ValidateObject('analyzeFinishedVideoGraphicsSync');
                    try {
                        vo.objectIsInteger(expectedDeltaMillis, 'expectedDeltaMillis');
                        vo.objectIsNonNegativeInteger(maxDifferenceMillis, 'maxDifferenceMillis');
                        vo.objectIsFunctionOrFalsy(callback, 'callback');
                    } catch (ex) {
                        comms.makeTestFail(ex);
                        return;
                    }

                    comms.queueSimpleXhr(URLS.analyzeFinishVideoGraphicsSync +
                            'step_number=' + stepId +
                            '&expected_delta_millis=' + expectedDeltaMillis +
                            '&max_difference_millis=' + maxDifferenceMillis,
                            'analyzeFinishVideoGraphicsSync',
                            wrapCallback(callback, callbackObject));
                }

                checkCallback(callback, callbackObject, analyzeFinishedVideoGraphicsSync);
            }

            comms.queueSimpleXhr(URLS.analyzeStartVideoGraphicsSync +
                    'step_number=' + stepId +
                    '&comment=' + encodeURIComponent(comment),
                    'analyzeStartVideoGraphicsSync',
                    analyzeStartVideoGraphicsSyncCb);
        };

        /** For a DUT that is in inter-device synchronization master mode,
         * this function checks the synchronization between the timeline
         * reported by the DUT and video, audio and/or subtitles.
         *
         * @param {integer} stepId
         * @param {string} comment
         * @param {string} wcUrl
         * @param {string} tsUrl
         * @param {string} contentIdStem
         * @param {string} timelineSelector
         * @param {integer} unitsPerTick
         * @param {integer} unitsPerSecond
         * @param {integer} patternStart
         * @param {integer} patternRepeatLength
         * @param {integer[]} pattern
         * @param {boolean} checkLight1AgainstTimeline
         * @param {boolean} checkLight2AgainstTimeline
         * @param {boolean} checkAudioAgainstTimeline
         * @param {integer} maxDispersionMillis
         * @param {integer} maxExtraDifferenceMillis
         * @param {function(Object)} callback
         * @param {Object} callbackObject
         */
        this.analyzeAvNetSync = function (stepId,
                                          comment,
                                          wcUrl,
                                          tsUrl,
                                          contentIdStem,
                                          timelineSelector,
                                          unitsPerTick,
                                          unitsPerSecond,
                                          patternStart,
                                          patternRepeatLength,
                                          pattern,
                                          checkLight1AgainstTimeline,
                                          checkLight2AgainstTimeline,
                                          checkAudioAgainstTimeline,
                                          maxDispersionMillis,
                                          maxExtraDifferenceMillis,
                                          callback,
                                          callbackObject) {
            var vo = new ValidateObject('analyzeAvNetSync');
            var MIN_PATTERN_VALUE = 0;
            var MAX_PATTERN_VALUE = 60 * 60 * 1000; // 60 minutes of sample data
            var MIN_PATTERN_SIZE = 1;
            var MAX_PATTERN_SIZE = 60 * 60 * 1000; // 60 minutes of sample data

            try {
                vo.objectIsNonNegativeInteger(stepId, 'stepId');
                vo.objectIsString(comment, 'comment');
                vo.objectIsFormattedString(wcUrl, '^[Uu][Dd][Pp]://.+$',
                    'wcUrl is a string with value ' + wcUrl +
                    '. This must be a string that starts with udp://',
                    'wcUrl');
                vo.objectIsFormattedString(tsUrl, '^[Ww][Ss]://.+$',
                    'tsUrl is a string with value ' + tsUrl +
                    '. This must be a string that starts with ws://',
                    'tsUrl');
                vo.objectIsString(contentIdStem, 'contentIdStem');
                vo.objectIsString(timelineSelector, 'timelineSelector');
                vo.objectIsPositiveInteger(unitsPerTick, 'unitsPerTick');
                vo.objectIsPositiveInteger(unitsPerSecond, 'unitsPerSecond');
                vo.objectIsNonNegativeInteger(patternStart, 'patternStart');
                vo.objectIsPositiveInteger(patternRepeatLength, 'patternRepeatLength');
                vo.objectIsIntArray(pattern, "pattern",
                                    MIN_PATTERN_SIZE, MAX_PATTERN_SIZE,
                                    MIN_PATTERN_VALUE, MAX_PATTERN_VALUE);
                vo.objectIsBoolean(checkLight1AgainstTimeline, 'checkLight1AgainstTimeline');
                vo.objectIsBoolean(checkLight2AgainstTimeline, 'checkLight2AgainstTimeline');
                vo.objectIsBoolean(checkAudioAgainstTimeline, 'checkAudioAgainstTimeline');
                vo.objectIsNonNegativeInteger(maxDispersionMillis, 'maxDispersionMillis');
                vo.objectIsNonNegativeInteger(maxExtraDifferenceMillis, 'maxExtraDifferenceMillis');
                vo.objectIsFunctionOrFalsy(callback, 'callback');
            } catch (ex) {
                comms.makeTestFail(ex);
                return;
            }

            comms.executeAnalyseStep(URLS.analyzeAvNetSync +
                    "step_number=" + stepId +
                    "&comment=" + encodeURIComponent(comment) +
                    "&wc_url=" + encodeURIComponent(wcUrl) +
                    "&ts_url=" + encodeURIComponent(tsUrl) +
                    "&content_id_stem=" + encodeURIComponent(contentIdStem) +
                    "&timeline_selector=" + encodeURIComponent(timelineSelector) +
                    "&units_per_tick=" + unitsPerTick +
                    "&units_per_second=" + unitsPerSecond +
                    "&pattern_start=" + patternStart +
                    "&pattern_repeat_length=" + patternRepeatLength +
                    "&pattern=" + pattern.join() +
                    "&check_light_1_against_timeline=" + checkLight1AgainstTimeline +
                    "&check_light_2_against_timeline=" + checkLight2AgainstTimeline +
                    "&check_audio_against_timeline=" + checkAudioAgainstTimeline +
                    "&max_dispersion_millis=" + maxDispersionMillis +
                    "&max_extra_difference_millis=" + maxExtraDifferenceMillis,
                    wrapCallback(callback, callbackObject));
        };

        /** Starts a fake inter-device synchronization master
         * running on the Test Harness, which the DUT can connect to.
         *
         * @param {Object} ciiData
         * @param {integer} timelineStartValue
         * @param {function(Object, string, string)} callback
         * @param {Object} callbackObject
         * @param {integer} timelineStartSeconds
         * @param {integer} timelineStartMicroseconds
         */
        this.startFakeSyncMaster = function (ciiData,
                                             timelineStartValue,
                                             callback,
                                             callbackObject,
                                             timelineStartSeconds,
                                             timelineStartMicroseconds) {
            var vo = new ValidateObject('startFakeSyncMaster');
            var timelineStartTime = "";
            if (JSON === undefined) {
                comms.makeTestFail("JSON is not available");
                return;
            }
            if (typeof (JSON.stringify) !== "function") {
                comms.makeTestFail("JSON.stringify is not available");
                return;
            }

            try {
                vo.objectIsDictionary(ciiData, "ciiData");
                vo.objectIsNonNegativeInteger(timelineStartValue, 'timelineStartValue');
                vo.objectIsFunctionOrFalsy(callback, 'callback');
                if (timelineStartSeconds !== null || timelineStartMicroseconds !== null) {
                    vo.objectIsInteger(timelineStartSeconds, 'timelineStartSeconds');
                    vo.objectIsIntegerInRange(timelineStartMicroseconds, 0, 999999, 'timelineStartMicroseconds');
                    timelineStartTime = timelineStartSeconds + "," + timelineStartMicroseconds;
                }
            } catch (ex) {
                comms.makeTestFail(ex);
                return;
            }

            /**
             * The callback function called when startFakeSyncMaster
             * has successfully been called in the python code.
             * @param {dictionary} data The data returned by the python code.
             */
            function startFakeSyncMasterCb(data) {
                var ciiURL = data.cii_url;
                var syncTestURL = data.sync_test_url;
                checkCallback(callback, callbackObject, ciiURL, syncTestURL);
            }

            comms.queueSimplePostXhr(URLS.startFakeSyncMaster,
                    'startFakeSyncMaster',
                    startFakeSyncMasterCb,
                    'timeline_start_value=' + timelineStartValue +
                    '&timeline_start_time=' + timelineStartTime +
                    '&cii_data=' + postEncode(JSON.stringify(ciiData)));
        };

        /** Gets the time that DVB TS playout started
         *
         * @param {integer} multiplexIndex
         * @param {function(Object, integer, integer, integer)} callback
         * @param {Object} callbackObject
         */
        this.getPlayoutStartTime = function (multiplexIndex,
                                             callback,
                                             callbackObject) {
            var vo = new ValidateObject('getPlayoutStartTime');

            try {
                vo.objectIsNonNegativeInteger(multiplexIndex, 'multiplexIndex');
                vo.objectIsFunction(callback, 'callback');
            } catch (ex) {
                comms.makeTestFail(ex);
                return;
            }

            /**
             * The callback function called when getPlayoutStartTime
             * has successfully been called in the python code.
             * @param {dictionary} data The data returned by the python code.
             */
            function getPlayoutStartTimeCb(data) {
                var seconds = data.seconds;
                var microseconds = data.microseconds;
                var maxErrorMicroseconds = data.max_error_microseconds;
                checkCallback(callback,
                             callbackObject,
                             seconds,
                             microseconds,
                             maxErrorMicroseconds);
            }

            comms.queueSimpleXhr(URLS.getPlayoutStartTime +
                    'multiplex_index=' + multiplexIndex,
                    'getPlayoutStartTime', getPlayoutStartTimeCb);
        };

        /** Analyse the css wallclock performance
         *
         * @param {int} stepId
         * @param {string} comment
         * @param {string} cssWcUrl
         * @param {int} numberOfClients
         * @param {int} numberOfMessages
         * @param {int} transmitDurationMillis
         * @param {int} maxDroppedRequests
         * @param {int} maxResponseTimeMillis
         * @param {function(Object)} callback
         * @param {Object} callbackObject
         */
        this.analyzeCssWcPerformance = function (stepId,
                                                 comment,
                                                 cssWcUrl,
                                                 numberOfClients,
                                                 numberOfMessages,
                                                 transmitDurationMillis,
                                                 maxDroppedRequests,
                                                 maxResponseTimeMillis,
                                                 callback,
                                                 callbackObject) {
            var vo = new ValidateObject('analyzeCssWcPerformance');

            try {
                vo.objectIsNonNegativeInteger(stepId, 'stepId');
                vo.objectIsString(comment, 'comment');
                vo.objectIsString(cssWcUrl, 'cssWcUrl');
                vo.objectIsNonNegativeInteger(numberOfClients, 'numberOfClients');
                vo.objectIsNonNegativeInteger(numberOfMessages, 'numberOfMessages');
                vo.objectIsNonNegativeInteger(transmitDurationMillis, 'transmitDurationMillis');
                vo.objectIsNonNegativeInteger(maxDroppedRequests, 'maxDroppedRequests');
                vo.objectIsNonNegativeInteger(maxResponseTimeMillis, 'maxResponseTimeMillis');
                vo.objectIsFunction(callback, 'callback');
            } catch (ex) {
                comms.makeTestFail(ex);
                return;
            }

            comms.executeAnalyseStep(URLS.analyzeCssWcPerformance +
                    "step_number=" + stepId +
                    "&comment=" + encodeURIComponent(comment) +
                    "&css_wc_url=" + encodeURIComponent(cssWcUrl) +
                    "&number_of_clients=" + numberOfClients +
                    "&number_of_messages=" + numberOfMessages +
                    "&transmit_duration_millis=" + transmitDurationMillis +
                    "&max_dropped_requests=" + maxDroppedRequests +
                    "&max_response_time_millis=" + maxResponseTimeMillis,
                    wrapCallback(callback, callbackObject));
        };

        /** Public function 7.3.9.<p>
         *
         * Requests to select a service by a sequence of
         * (mainly numeric) key codes that is sent to the DUT. This
         * is implemented by directly sending IR codes by a request to the
         * tester to do so manually, similar to reportMessage). The service
         * selection shall switch directly from the current to the new service.
         *
         * @param {string} serviceName The service to select by remote.
         * @param {function(Object)} callback A callback function to invoke
         *         when the key codes were actually sent to the receiver.
         * @param {Object} callbackObject
         */
        this.selectServiceByRemoteControl = function (serviceName,
                                                       callback,
                                                       callbackObject) {
            // Validate parameters.
            var vo = new ValidateObject('selectServiceByRemoteControl');
            serviceName = vo.convertStringToPrimitive(serviceName);
            try {
                vo.objectIsString(serviceName, 'service_name');
                vo.objectIsFunctionOrFalsy(callback, 'callback');
            } catch (ex) {
                comms.makeTestFail(ex);
                return;
            }

            comms.executeAnalyseStep(URLS.selectServiceByRemoteControl +
                               'service_name=' + encodeURIComponent(serviceName),
                               wrapCallback(callback, callbackObject));
        };

        // ---- 7.4 APIs Interacting with the Playout Environment  ------------

        /** Public API function 7.4.5.
         *
         * @param {integer} playoutSetId
         * @param {function(Object)} callback
         * @param {Object} callbackObject
         */
        this.changePlayoutSet = function (playoutSetId, callback, callbackObject) {
            // The AJAX request returns after we've stopped the old stream
            // generator and at about the same time we start the new one.
            // But, there are buffers between the stream generation code and
            // the output of the modulator.  (These are the buffers in
            // LigadaDvbBroadcaster.exe and on the modulator hardware).
            // These have been measured at about 3 seconds (for DVB-C &
            // DVB-S).  So we insert a delay before we call the test's
            // callback function.

            var vo = new ValidateObject('changePlayoutSet');

            try {
                vo.objectIsInteger(playoutSetId, 'playoutSetId');
                vo.objectIsFunctionOrFalsy(callback, 'callback');
            } catch (ex) {
                comms.makeTestFail(ex);
                return;
            }

            var STREAM_BUFFERS_SIZE_MILLIS = 3500;
            var timerCallback = wrapCallback(callback, callbackObject);
            function changePlayoutSetCallback() {
                window.setTimeout(timerCallback, STREAM_BUFFERS_SIZE_MILLIS);
            }
            comms.queueSimpleXhr(URLS.changePlayoutSet +
                                 'playoutset=' + playoutSetId,
                                 'changePlayoutSet',
                                 changePlayoutSetCallback);
        };

        /** Public API function 7.4.6.
         *
         * @param {integer} rate
         * @param {function(Object)} callback
         * @param {Object} callbackObject
         */
        this.setNetworkBandwidth = function (rate, callback, callbackObject) {
            var vo = new ValidateObject('setNetworkBandwidth');

            try {
                vo.objectIsNonNegativeInteger(rate, 'rate');
                vo.objectIsFunctionOrFalsy(callback, 'callback');
            } catch (ex) {
                comms.makeTestFail(ex);
                return;
            }

            var cb = wrapCallback(callback, callbackObject);
            if (comms.isTestComplete()) {
                cb();
                return;
            }
            comms.queueSimpleXhr(URLS.setNetworkBandwidth + 'rate=' + rate,
                                 'setNetworkBandwidth', cb);
        };


        // ------------ OIPF public API extensions ----------------------------

        /** Open IPTV Forum Test Harness Specification 4.1.3.3.<p>
         *
         * Change the URL that the 'default page' redirects to.<p>
         *
         * Pass a URL, which will usually be a relative URL.  If it is a relative
         * URL, it shall be relative to the directory containing the test's
         * implementation.xml file.  The next time the DUT goes to the OIPF
         * Application Launcher (e.g. after a reboot), it will be redirected to
         * the specified URL.<p>
         *
         * This method is usually used just before a call to initiatePowerCycle().
         *
         * @param {string} url
         * @param {function(Object)} callback
         * @param {Object} callbackObject
         */
        this.setDefaultPage = function (url, callback, callbackObject) {
            var vo = new ValidateObject('setDefaultPage');
            try {
                // For now, just check for not empty, no embedded spaces, no
                // control characters (<32), no invalid bytes (i.e. >=256),
                // and no high-bit characters (i.e. >=128).
                vo.objectIsFormattedString(url, '^[\x21-\x7f]+$',
                    'url parameter is not a URL.  It has value "' + url + '"',
                    'url');
            } catch (ex) {
                comms.makeTestFail(ex);
                return;
            }
            var cb = wrapCallback(callback, callbackObject);
            comms.queueSimpleXhr(URLS.setDefaultPage +
                                 'url=' + encodeURIComponent(url),
                                 'setDefaultPage', cb);
        };



        // ------------ Ligada iSuite proprietary extensions API --------------

        /** Network Shaping.
         * (Optional Ligada feature).
         *
         * @param networkProfileId
         * @param callback
         * @param callbackObject
         */
        this.changeNetworkProfile = function (networkProfileId, callback, callbackObject) {
            var vo = new ValidateObject('changeNetworkProfile');

            try {
                vo.objectIsPositiveInteger(networkProfileId, 'networkProfileId');
                vo.objectIsFunctionOrFalsy(callback, 'callback');
            } catch (ex) {
                comms.makeTestFail(ex);
                return;
            }

            var cb = wrapCallback(callback, callbackObject);
            if (comms.isTestComplete()) {
                cb();
                return;
            }
            comms.queueSimpleXhr(URLS.changeNetworkProfile +
                                 'networkProfileId=' + networkProfileId,
                                 'changeNetworkProfile', cb);
        };

        /** Ligada-specific extension.
         * NOT TO BE USED BY TEST CASES!
         *
         * Used by Ligada regression tests.
         * Print a debug message.  Uses OIPF global window.debug(), (S7.15.5,
         * p208 OIPF), and a special magic <div>.  Does not do any
         * XMLHttpRequests.
         *
         * @param {string} msg Message to print.
         */
        this.debug = function (msg) {
            debugPrint(msg);
        };


        // ------------- Initialisation code ----------------------------------

        /** CI+ testing API
         * @type Internal.CicamAPI
         */
        this.cicam = new CicamAPI(comms);

        // ------------- Websockets Initialisation ----------------------------------
        // Try to find the implementation of the standard W3C Websockets API.
        if (launch_mode.is_unit_test) {
            // Internal unit tests will already have defined a mock to use for
            // the WebSocket so use it
            WebSocket = global.WebSocket;
        } else if (launch_mode.is_harness_application) {
            // For harness-based tests use a node.js implementation of
            // WebSocket.
            WebSocket = require('/usr/local/lib/node_modules/ws');
        } else if (window && window.WebSocket) {
            // For tests running in a browser that supports the W3C Websockets
            // API, use that.  Note that this API is mandatory in HbbTV 1.3.1
            // and optional in earlier versions of HbbTV.
            WebSocket = window.WebSocket;
        }

        /** Creating a new instance of the Websocket manager for use in
         * openWebsockets API
         */
        var wsmanager = new WebsocketManager(WebSocket);

        // ------------ HbbTV Websocket testing API ---------------------------


        /** TestAPI.openWebsocket() as defined in Section 7.7.2 of
         * HbbTV Test Spec.<br>
         * <br>
         * NOTE: to use this API, EITHER this must be a harness-based test,<br>
         *       OR the HTML page containing this JavaScript must have an
         *       Origin that either ends with ".test", or matches "a.aa"
         *       exactly.  This is enforced by the Ligada VM, and is for
         *       security reasons.  See RFC 6454 and the HbbTV spec for
         *       details of how a web browser determines the Origin.<br>
         *       In practise, normal HbbTV tests launched from the HTTP server
         *       in the Test Harness will be able to use this API, but tests
         *       launched from DSMCC or from a server on the Internet will not
         *       be able to use this API due to the Origin check.<br>
         * <br>
         * NOTE: The Origin check prevents the following security
         *       vulnerability: an organization happens to have Ligada
         *       installed somewhere.  Someone at the organization visits
         *       a malicious webpage.  The malicious page instructs their
         *       browser to make a Websocket connection to Ligada, and then
         *       sends commands over that Websocket instructing Ligada to
         *       connect to a secure internal server using a spoofed Origin
         *       header.  That would allow an attacker who is targetting
         *       a particular company to get Websocket access to an internal
         *       server (inside the corporate firewall).  To prevent this,
         *       Ligada will reject the Websocket connection from the
         *       malicious page, based on the Origin header supplied by the
         *       browser.
         *
         * @param {string} url The Websockets URL
         * @param {function} onConnect Callback when WebSocket connection is established
         * @param {function} onMessage Callback when WebSocket message is received
         * @param {function} onPong Callback when PONG frame is received
         * @param {function} onClose Callback when WebSocket connection is closed
         * @param {function} onFail Callback when WebSocket connection has been failed
         * @param {Object} callbackObject Object to be passed to all callbacks
         * @param {string | null} originHeader Sent as 'Origin' field
         * @param {string | null} websocketsExtensionHeader Sent as 'Sec-WebSocket-Extensions' field
         */
        this.openWebsocket = function (url, onConnect, onMessage, onPong,
                                       onClose, onFail, callbackObject,
                                       originHeader,
                                       websocketsExtensionHeader) {

            // Validate the input parameters passed to openWebsocket
            var vo = new ValidateObject('openWebsocket');
            url = vo.convertStringToPrimitive(url);
            if (originHeader === undefined) {
                originHeader = null;
            }
            if (websocketsExtensionHeader === undefined) {
                websocketsExtensionHeader = null;
            }
            originHeader = vo.convertStringToPrimitive(originHeader);
            websocketsExtensionHeader = vo.convertStringToPrimitive(websocketsExtensionHeader);
            try {
                vo.objectIsString(url, 'url');
                vo.objectIsNullOrString(originHeader, 'originHeader');
                vo.objectIsNullOrString(websocketsExtensionHeader, 'websocketsExtensionHeader');
                vo.objectIsFunctionOrFalsy(onConnect, 'onConnect');
                vo.objectIsFunctionOrFalsy(onMessage, 'onMessage');
                vo.objectIsFunctionOrFalsy(onPong, 'onPong');
                vo.objectIsFunctionOrFalsy(onClose, 'onClose');
                vo.objectIsFunctionOrFalsy(onFail, 'onFail');
            } catch (ex) {
                comms.makeTestFail(ex);
                return;
            }

            // Check that JSON.parse/JSON.stringify have been implemented
            if (JSON === undefined) {
                comms.makeTestFail("JSON API is not available");
                return;
            }

            if (typeof (JSON.parse) !== "function") {
                comms.makeTestFail("JSON.parse API is not available");
                return;
            }

            if (typeof (JSON.stringify) !== "function") {
                comms.makeTestFail("JSON.stringify API is not available");
                return;
            }

            wsmanager.requestNewWebsocketClient(url, onConnect, onMessage,
                                                onPong, onClose, onFail,
                                                callbackObject, originHeader,
                                                websocketsExtensionHeader,
                                                comms);

        };

        /** Companion Screen testing support.
         * @type Internal.DialTestAPI
         */
        this.dial = new DialTestAPI(comms);

        comms.initialize();
    }

    return HbbTVTestAPI;  // Export this (and ONLY this) to global context
}());


// Detect node.js.  This if () should evaluate to true in node.js, but false in
// any browser.
if (typeof module !== 'undefined' && typeof global !== 'undefined' &&
        module.exports && this.module !== module) {
    // Make HbbTVTestAPI really global.
    global.HbbTVTestAPI = HbbTVTestAPI;
}
